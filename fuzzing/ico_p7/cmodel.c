#include "cmodel.h"
sol_raw_uint160_t g_literal_address_0;
int called_a;
int called_b;
sol_address_t tmp_sender;
struct Map_2 {
  sol_uint256_t sum;
  sol_uint256_t data_0_0;
  sol_uint256_t data_0_1;
  sol_uint256_t data_0_2;
  sol_uint256_t data_0_3;
  sol_uint256_t data_0_4;
  sol_uint256_t data_0_5;
  sol_uint256_t data_0_6;
  sol_uint256_t data_0_7;
  sol_uint256_t data_0_8;
  sol_uint256_t data_0_9;
  sol_uint256_t data_0_10;
  sol_uint256_t data_0_11;
  sol_uint256_t data_1_0;
  sol_uint256_t data_1_1;
  sol_uint256_t data_1_2;
  sol_uint256_t data_1_3;
  sol_uint256_t data_1_4;
  sol_uint256_t data_1_5;
  sol_uint256_t data_1_6;
  sol_uint256_t data_1_7;
  sol_uint256_t data_1_8;
  sol_uint256_t data_1_9;
  sol_uint256_t data_1_10;
  sol_uint256_t data_1_11;
  sol_uint256_t data_2_0;
  sol_uint256_t data_2_1;
  sol_uint256_t data_2_2;
  sol_uint256_t data_2_3;
  sol_uint256_t data_2_4;
  sol_uint256_t data_2_5;
  sol_uint256_t data_2_6;
  sol_uint256_t data_2_7;
  sol_uint256_t data_2_8;
  sol_uint256_t data_2_9;
  sol_uint256_t data_2_10;
  sol_uint256_t data_2_11;
  sol_uint256_t data_3_0;
  sol_uint256_t data_3_1;
  sol_uint256_t data_3_2;
  sol_uint256_t data_3_3;
  sol_uint256_t data_3_4;
  sol_uint256_t data_3_5;
  sol_uint256_t data_3_6;
  sol_uint256_t data_3_7;
  sol_uint256_t data_3_8;
  sol_uint256_t data_3_9;
  sol_uint256_t data_3_10;
  sol_uint256_t data_3_11;
  sol_uint256_t data_4_0;
  sol_uint256_t data_4_1;
  sol_uint256_t data_4_2;
  sol_uint256_t data_4_3;
  sol_uint256_t data_4_4;
  sol_uint256_t data_4_5;
  sol_uint256_t data_4_6;
  sol_uint256_t data_4_7;
  sol_uint256_t data_4_8;
  sol_uint256_t data_4_9;
  sol_uint256_t data_4_10;
  sol_uint256_t data_4_11;
  sol_uint256_t data_5_0;
  sol_uint256_t data_5_1;
  sol_uint256_t data_5_2;
  sol_uint256_t data_5_3;
  sol_uint256_t data_5_4;
  sol_uint256_t data_5_5;
  sol_uint256_t data_5_6;
  sol_uint256_t data_5_7;
  sol_uint256_t data_5_8;
  sol_uint256_t data_5_9;
  sol_uint256_t data_5_10;
  sol_uint256_t data_5_11;
  sol_uint256_t data_6_0;
  sol_uint256_t data_6_1;
  sol_uint256_t data_6_2;
  sol_uint256_t data_6_3;
  sol_uint256_t data_6_4;
  sol_uint256_t data_6_5;
  sol_uint256_t data_6_6;
  sol_uint256_t data_6_7;
  sol_uint256_t data_6_8;
  sol_uint256_t data_6_9;
  sol_uint256_t data_6_10;
  sol_uint256_t data_6_11;
  sol_uint256_t data_7_0;
  sol_uint256_t data_7_1;
  sol_uint256_t data_7_2;
  sol_uint256_t data_7_3;
  sol_uint256_t data_7_4;
  sol_uint256_t data_7_5;
  sol_uint256_t data_7_6;
  sol_uint256_t data_7_7;
  sol_uint256_t data_7_8;
  sol_uint256_t data_7_9;
  sol_uint256_t data_7_10;
  sol_uint256_t data_7_11;
  sol_uint256_t data_8_0;
  sol_uint256_t data_8_1;
  sol_uint256_t data_8_2;
  sol_uint256_t data_8_3;
  sol_uint256_t data_8_4;
  sol_uint256_t data_8_5;
  sol_uint256_t data_8_6;
  sol_uint256_t data_8_7;
  sol_uint256_t data_8_8;
  sol_uint256_t data_8_9;
  sol_uint256_t data_8_10;
  sol_uint256_t data_8_11;
  sol_uint256_t data_9_0;
  sol_uint256_t data_9_1;
  sol_uint256_t data_9_2;
  sol_uint256_t data_9_3;
  sol_uint256_t data_9_4;
  sol_uint256_t data_9_5;
  sol_uint256_t data_9_6;
  sol_uint256_t data_9_7;
  sol_uint256_t data_9_8;
  sol_uint256_t data_9_9;
  sol_uint256_t data_9_10;
  sol_uint256_t data_9_11;
  sol_uint256_t data_10_0;
  sol_uint256_t data_10_1;
  sol_uint256_t data_10_2;
  sol_uint256_t data_10_3;
  sol_uint256_t data_10_4;
  sol_uint256_t data_10_5;
  sol_uint256_t data_10_6;
  sol_uint256_t data_10_7;
  sol_uint256_t data_10_8;
  sol_uint256_t data_10_9;
  sol_uint256_t data_10_10;
  sol_uint256_t data_10_11;
  sol_uint256_t data_11_0;
  sol_uint256_t data_11_1;
  sol_uint256_t data_11_2;
  sol_uint256_t data_11_3;
  sol_uint256_t data_11_4;
  sol_uint256_t data_11_5;
  sol_uint256_t data_11_6;
  sol_uint256_t data_11_7;
  sol_uint256_t data_11_8;
  sol_uint256_t data_11_9;
  sol_uint256_t data_11_10;
  sol_uint256_t data_11_11;
};
struct Map_1 {
  sol_uint256_t sum;
  sol_uint256_t data_0;
  sol_uint256_t data_1;
  sol_uint256_t data_2;
  sol_uint256_t data_3;
  sol_uint256_t data_4;
  sol_uint256_t data_5;
  sol_uint256_t data_6;
  sol_uint256_t data_7;
  sol_uint256_t data_8;
  sol_uint256_t data_9;
  sol_uint256_t data_10;
  sol_uint256_t data_11;
};
struct GVToken {
  sol_address_t model_address;
  sol_uint256_t model_balance;
  sol_address_t user_ico;
  sol_bool_t user_isFrozen;
  sol_address_t user_migrationMaster;
  sol_address_t user_migrationAgent;
  sol_uint256_t user_totalMigrated;
  struct Map_2 user_allowed;
  struct Map_1 user_balances;
  sol_uint256_t user_totalSupply;
};
struct GVOptionToken {
  sol_address_t model_address;
  sol_uint256_t model_balance;
  sol_address_t user_optionProgram;
  sol_uint256_t user_name;
  sol_uint256_t user_symbol;
  sol_uint256_t user_TOKEN__LIMIT;
  struct Map_2 user_allowed;
  struct Map_1 user_balances;
  sol_uint256_t user_totalSupply;
};
struct GVOptionProgram {
  sol_address_t model_address;
  sol_uint256_t model_balance;
  sol_address_t user_gvAgent;
  sol_address_t user_team;
  sol_address_t user_ico;
  struct GVOptionToken user_gvOptionToken30;
  struct GVOptionToken user_gvOptionToken20;
  struct GVOptionToken user_gvOptionToken10;
};
struct ICO {
  sol_address_t model_address;
  sol_uint256_t model_balance;
  sol_address_t user_gvAgent;
  sol_address_t user_team;
  struct GVToken user_gvToken;
  struct GVOptionProgram user_optionProgram;
  sol_address_t user_teamAllocator;
  sol_address_t user_migrationMaster;
  sol_uint256_t user_tokensSold;
  sol_bool_t user_isPaused;
  sol_uint8_t user_icoState;
};
sol_uint256_t SafeMath_Method_sub(sol_uint256_t func_user_a,
                                  sol_uint256_t func_user_b);
sol_uint256_t SafeMath_Method_add(sol_uint256_t func_user_a,
                                  sol_uint256_t func_user_b);
sol_uint256_t ICO_Method_buyTokensInternal(
    struct ICO *self, sol_address_t sender, sol_uint256_t value,
    sol_uint256_t blocknum, sol_uint256_t timestamp, sol_bool_t paid,
    sol_address_t origin, sol_address_t func_user_buyer,
    sol_uint256_t func_user_usdCents, sol_uint256_t func_user_txHash);
struct Map_2 ZeroInit_Map_2(void);
sol_uint256_t Read_Map_2(struct Map_2 *arr, sol_address_t key_0,
                         sol_address_t key_1);
void Write_Map_2(struct Map_2 *arr, sol_address_t key_0, sol_address_t key_1,
                 sol_uint256_t dat);
struct Map_1 ZeroInit_Map_1(void);
sol_uint256_t Read_Map_1(struct Map_1 *arr, sol_address_t key_0);
void Write_Map_1(struct Map_1 *arr, sol_address_t key_0, sol_uint256_t dat);
sol_uint256_t GVOptionProgram_Method_executeIfAvailable(
    struct GVOptionProgram *self, sol_address_t sender, sol_uint256_t value,
    sol_uint256_t blocknum, sol_uint256_t timestamp, sol_bool_t paid,
    sol_address_t origin, sol_uint256_t *func_user_remainingCents,
    sol_address_t func_user_buyer, sol_uint256_t func_user_usdCents,
    sol_uint256_t func_user_txHash, struct GVOptionToken func_user_optionToken,
    sol_uint8_t func_user_optionType, sol_uint256_t func_user_optionPerCent);
sol_uint256_t GVOptionProgram_Method_buyIfAvailable(
    struct GVOptionProgram *self, sol_address_t sender, sol_uint256_t value,
    sol_uint256_t blocknum, sol_uint256_t timestamp, sol_bool_t paid,
    sol_address_t origin, sol_address_t func_user_buyer,
    sol_uint256_t func_user_usdCents, sol_uint256_t func_user_txHash,
    struct GVOptionToken func_user_optionToken,
    sol_uint8_t func_user_optionType, sol_uint256_t func_user_optionsPerCent);
sol_uint256_t SafeMath_Method_sub(sol_uint256_t func_user_a,
                                  sol_uint256_t func_user_b) {
  sol_require(((func_user_b).v) <= ((func_user_a).v), 0);
  { return Init_sol_uint256_t(((func_user_a).v) - ((func_user_b).v)); }
}
sol_uint256_t SafeMath_Method_add(sol_uint256_t func_user_a,
                                  sol_uint256_t func_user_b) {
  sol_uint256_t func_user_c =
      Init_sol_uint256_t(((func_user_a).v) + ((func_user_b).v));
  sol_require(((func_user_c).v) >= ((func_user_a).v), 0);
  { return Init_sol_uint256_t((func_user_c).v); }
}
void ICO_Constructor(struct ICO *self, sol_address_t sender,
                     sol_uint256_t value, sol_uint256_t blocknum,
                     sol_uint256_t timestamp, sol_bool_t paid,
                     sol_address_t origin, sol_address_t func_user___team,
                     sol_address_t func_user___gvAgent,
                     sol_address_t func_user___migrationMaster,
                     sol_address_t func_user___teamAllocator) {
  ((self->user_gvAgent).v) = ((func_user___gvAgent).v);
  ((self->user_team).v) = ((func_user___team).v);
  ((self->user_teamAllocator).v) = ((func_user___teamAllocator).v);
  ((self->user_migrationMaster).v) = ((func_user___migrationMaster).v);
  Init_GVToken(&(self->user_gvToken), (self)->model_address,
               Init_sol_uint256_t(0), blocknum, timestamp, Init_sol_bool_t(1),
               origin, Init_sol_address_t(((self)->model_address).v),
               Init_sol_address_t((self->user_migrationMaster).v));
  Init_GVOptionProgram(&(self->user_optionProgram), (self)->model_address,
                       Init_sol_uint256_t(0), blocknum, timestamp,
                       Init_sol_bool_t(1), origin,
                       Init_sol_address_t(((self)->model_address).v),
                       Init_sol_address_t((self->user_gvAgent).v),
                       Init_sol_address_t((self->user_team).v));
}
void Init_ICO(struct ICO *self, sol_address_t sender, sol_uint256_t value,
              sol_uint256_t blocknum, sol_uint256_t timestamp, sol_bool_t paid,
              sol_address_t origin, sol_address_t user___team,
              sol_address_t user___gvAgent,
              sol_address_t user___migrationMaster,
              sol_address_t user___teamAllocator) {
  ((self)->model_balance) = (Init_sol_uint256_t(0));
  ((self)->user_gvAgent) = (Init_sol_address_t(0));
  ((self)->user_team) = (Init_sol_address_t(0));
  ((self)->user_teamAllocator) = (Init_sol_address_t(0));
  ((self)->user_migrationMaster) = (Init_sol_address_t(0));
  ((self)->user_tokensSold) = (Init_sol_uint256_t(0));
  ((self)->user_isPaused) = (Init_sol_bool_t(0));
  ((self)->user_icoState) = (Init_sol_uint8_t(0));
  ICO_Constructor(self, sender, value, blocknum, timestamp, Init_sol_bool_t(0),
                  origin, user___team, user___gvAgent, user___migrationMaster,
                  user___teamAllocator);
}
void ICO_Method_1_initOptionProgram(struct ICO *self, sol_address_t sender,
                                    sol_uint256_t value, sol_uint256_t blocknum,
                                    sol_uint256_t timestamp, sol_bool_t paid,
                                    sol_address_t origin) {
  if ((((self->user_optionProgram).model_address).v) == (g_literal_address_0)) {
    sol_assert(0, 0);
  }
}
void ICO_Method_initOptionProgram(struct ICO *self, sol_address_t sender,
                                  sol_uint256_t value, sol_uint256_t blocknum,
                                  sol_uint256_t timestamp, sol_bool_t paid,
                                  sol_address_t origin) {
  sol_require(((sender).v) == ((self->user_team).v), 0);
  ICO_Method_1_initOptionProgram(self, sender, value, blocknum, timestamp,
                                 Init_sol_bool_t(0), origin);
}
void ICO_Method_1_startOptionsSelling(struct ICO *self, sol_address_t sender,
                                      sol_uint256_t value,
                                      sol_uint256_t blocknum,
                                      sol_uint256_t timestamp, sol_bool_t paid,
                                      sol_address_t origin) {
  sol_require(((self->user_icoState).v) == (0), 0);
  sol_require((((self->user_optionProgram).model_address).v) !=
                  (g_literal_address_0),
              0);
  ((self->user_icoState).v) = (1);
  { sol_emit("StartOptionsSelling()"); }
}
void ICO_Method_startOptionsSelling(struct ICO *self, sol_address_t sender,
                                    sol_uint256_t value, sol_uint256_t blocknum,
                                    sol_uint256_t timestamp, sol_bool_t paid,
                                    sol_address_t origin) {
  sol_require(((sender).v) == ((self->user_team).v), 0);
  ICO_Method_1_startOptionsSelling(self, sender, value, blocknum, timestamp,
                                   Init_sol_bool_t(0), origin);
}
void ICO_Method_1_startIcoForOptionsHolders(
    struct ICO *self, sol_address_t sender, sol_uint256_t value,
    sol_uint256_t blocknum, sol_uint256_t timestamp, sol_bool_t paid,
    sol_address_t origin) {
  sol_require(((self->user_icoState).v) == (1), 0);
  ((self->user_icoState).v) = (2);
  { sol_emit("StartICOForOptionsHolders()"); }
}
void ICO_Method_startIcoForOptionsHolders(
    struct ICO *self, sol_address_t sender, sol_uint256_t value,
    sol_uint256_t blocknum, sol_uint256_t timestamp, sol_bool_t paid,
    sol_address_t origin) {
  sol_require(((sender).v) == ((self->user_team).v), 0);
  ICO_Method_1_startIcoForOptionsHolders(self, sender, value, blocknum,
                                         timestamp, Init_sol_bool_t(0), origin);
}
void ICO_Method_1_startIco(struct ICO *self, sol_address_t sender,
                           sol_uint256_t value, sol_uint256_t blocknum,
                           sol_uint256_t timestamp, sol_bool_t paid,
                           sol_address_t origin) {
  sol_require(((self->user_icoState).v) == (2), 0);
  ((self->user_icoState).v) = (3);
  { sol_emit("RunIco()"); }
}
void ICO_Method_startIco(struct ICO *self, sol_address_t sender,
                         sol_uint256_t value, sol_uint256_t blocknum,
                         sol_uint256_t timestamp, sol_bool_t paid,
                         sol_address_t origin) {
  sol_require(((sender).v) == ((self->user_team).v), 0);
  ICO_Method_1_startIco(self, sender, value, blocknum, timestamp,
                        Init_sol_bool_t(0), origin);
}
void ICO_Method_1_pauseIco(struct ICO *self, sol_address_t sender,
                           sol_uint256_t value, sol_uint256_t blocknum,
                           sol_uint256_t timestamp, sol_bool_t paid,
                           sol_address_t origin) {
  sol_require(!((self->user_isPaused).v), 0);
  sol_require(((((self->user_icoState).v) == (3)) ||
               (((self->user_icoState).v) == (2))) ||
                  (((self->user_icoState).v) == (1)),
              0);
  ((self->user_isPaused).v) = (1);
  { sol_emit("PauseIco()"); }
}
void ICO_Method_pauseIco(struct ICO *self, sol_address_t sender,
                         sol_uint256_t value, sol_uint256_t blocknum,
                         sol_uint256_t timestamp, sol_bool_t paid,
                         sol_address_t origin) {
  sol_require(((sender).v) == ((self->user_team).v), 0);
  ICO_Method_1_pauseIco(self, sender, value, blocknum, timestamp,
                        Init_sol_bool_t(0), origin);
}
void ICO_Method_1_resumeIco(struct ICO *self, sol_address_t sender,
                            sol_uint256_t value, sol_uint256_t blocknum,
                            sol_uint256_t timestamp, sol_bool_t paid,
                            sol_address_t origin) {
  sol_require((self->user_isPaused).v, 0);
  sol_require(((((self->user_icoState).v) == (3)) ||
               (((self->user_icoState).v) == (2))) ||
                  (((self->user_icoState).v) == (1)),
              0);
  ((self->user_isPaused).v) = (0);
  { sol_emit("ResumeIco()"); }
}
void ICO_Method_resumeIco(struct ICO *self, sol_address_t sender,
                          sol_uint256_t value, sol_uint256_t blocknum,
                          sol_uint256_t timestamp, sol_bool_t paid,
                          sol_address_t origin) {
  sol_require(((sender).v) == ((self->user_team).v), 0);
  ICO_Method_1_resumeIco(self, sender, value, blocknum, timestamp,
                         Init_sol_bool_t(0), origin);
}
void ICO_Method_1_finishIco(struct ICO *self, sol_address_t sender,
                            sol_uint256_t value, sol_uint256_t blocknum,
                            sol_uint256_t timestamp, sol_bool_t paid,
                            sol_address_t origin,
                            sol_address_t func_user___fund,
                            sol_address_t func_user___bounty) {
  sol_require(((self->user_icoState).v) == (3), 0);
  ((self->user_icoState).v) = (4);
  sol_uint256_t func_user_mintedTokens =
      Init_sol_uint256_t(((self->user_gvToken).user_totalSupply).v);
  if (((func_user_mintedTokens).v) > (0)) {
    sol_uint256_t func_user_totalAmount =
        Init_sol_uint256_t((((func_user_mintedTokens).v) * (4)) / (3));
    GVToken_Method_mint(
        &(self->user_gvToken), (self)->model_address, Init_sol_uint256_t(0),
        blocknum, timestamp, Init_sol_bool_t(1), origin,
        Init_sol_address_t((self->user_teamAllocator).v),
        Init_sol_uint256_t(((11) * ((func_user_totalAmount).v)) / (100)));
    GVToken_Method_mint(&(self->user_gvToken), (self)->model_address,
                        Init_sol_uint256_t(0), blocknum, timestamp,
                        Init_sol_bool_t(1), origin,
                        Init_sol_address_t((func_user___fund).v),
                        Init_sol_uint256_t(((func_user_totalAmount).v) / (20)));
    GVToken_Method_mint(
        &(self->user_gvToken), (self)->model_address, Init_sol_uint256_t(0),
        blocknum, timestamp, Init_sol_bool_t(1), origin,
        Init_sol_address_t((func_user___bounty).v),
        Init_sol_uint256_t(((9) * ((func_user_totalAmount).v)) / (100)));
    GVToken_Method_unfreeze(&(self->user_gvToken), (self)->model_address,
                            Init_sol_uint256_t(0), blocknum, timestamp,
                            Init_sol_bool_t(1), origin);
  }
  { sol_emit("FinishIco()"); }
}
void ICO_Method_finishIco(struct ICO *self, sol_address_t sender,
                          sol_uint256_t value, sol_uint256_t blocknum,
                          sol_uint256_t timestamp, sol_bool_t paid,
                          sol_address_t origin, sol_address_t func_model___fund,
                          sol_address_t func_model___bounty) {
  sol_require(((sender).v) == ((self->user_team).v), 0);
  ICO_Method_1_finishIco(self, sender, value, blocknum, timestamp,
                         Init_sol_bool_t(0), origin, func_model___fund,
                         func_model___bounty);
}
sol_uint256_t ICO_Method_1_buyTokens(
    struct ICO *self, sol_address_t sender, sol_uint256_t value,
    sol_uint256_t blocknum, sol_uint256_t timestamp, sol_bool_t paid,
    sol_address_t origin, sol_address_t func_user_buyer,
    sol_uint256_t func_user_usdCents, sol_uint256_t func_user_txHash) {
  sol_require(((self->user_icoState).v) == (3), 0);
  sol_require(!((self->user_isPaused).v), 0);
  {
    return Init_sol_uint256_t(
        (ICO_Method_buyTokensInternal(
             self, sender, value, blocknum, timestamp, Init_sol_bool_t(0),
             origin, Init_sol_address_t((func_user_buyer).v),
             Init_sol_uint256_t((func_user_usdCents).v),
             Init_sol_uint256_t((func_user_txHash).v)))
            .v);
  }
}
sol_uint256_t ICO_Method_buyTokens(struct ICO *self, sol_address_t sender,
                                   sol_uint256_t value, sol_uint256_t blocknum,
                                   sol_uint256_t timestamp, sol_bool_t paid,
                                   sol_address_t origin,
                                   sol_address_t func_model_buyer,
                                   sol_uint256_t func_model_usdCents,
                                   sol_uint256_t func_model_txHash) {
  sol_uint256_t func_model_rv;
  sol_require(((sender).v) == ((self->user_gvAgent).v), 0);
  (func_model_rv) = (ICO_Method_1_buyTokens(
      self, sender, value, blocknum, timestamp, Init_sol_bool_t(0), origin,
      func_model_buyer, func_model_usdCents, func_model_txHash));
  return func_model_rv;
}
sol_uint256_t ICO_Method_1_buyTokensByOptions(
    struct ICO *self, sol_address_t sender, sol_uint256_t value,
    sol_uint256_t blocknum, sol_uint256_t timestamp, sol_bool_t paid,
    sol_address_t origin, sol_address_t func_user_buyer,
    sol_uint256_t func_user_usdCents, sol_uint256_t func_user_txHash) {
  sol_require(!((self->user_isPaused).v), 0);
  sol_require((((self->user_icoState).v) == (3)) ||
                  (((self->user_icoState).v) == (2)),
              0);
  sol_require(((func_user_usdCents).v) > (0), 0);
  sol_uint256_t func_user_executedTokens;
  sol_uint256_t func_user_remainingCents;
  {
    sol_uint256_t blockvar_0;
    sol_uint256_t blockvar_1;
    ((blockvar_0).v) =
        ((GVOptionProgram_Method_executeOptions(
              &(self->user_optionProgram), (self)->model_address,
              Init_sol_uint256_t(0), blocknum, timestamp, Init_sol_bool_t(1),
              origin, &(blockvar_1), Init_sol_address_t((func_user_buyer).v),
              Init_sol_uint256_t((func_user_usdCents).v),
              Init_sol_uint256_t((func_user_txHash).v)))
             .v);
    ((func_user_executedTokens).v) = ((blockvar_0).v);
    ((func_user_remainingCents).v) = ((blockvar_1).v);
  }
  if (((func_user_executedTokens).v) > (0)) {
    sol_require((((self->user_tokensSold).v) +
                 ((func_user_executedTokens).v)) <= (330000000000000000),
                0);
    ((self->user_tokensSold).v) =
        (((self->user_tokensSold).v) + ((func_user_executedTokens).v));
    GVToken_Method_mint(&(self->user_gvToken), (self)->model_address,
                        Init_sol_uint256_t(0), blocknum, timestamp,
                        Init_sol_bool_t(1), origin,
                        Init_sol_address_t((func_user_buyer).v),
                        Init_sol_uint256_t((func_user_executedTokens).v));
    {
      (func_user_buyer).v;
      (func_user_executedTokens).v;
      (func_user_txHash).v;
      sol_emit("BuyTokens(buyer, executedTokens, txHash)");
    }
  }
  if (((self->user_icoState).v) == (3)) {
    {
      return Init_sol_uint256_t(
          (ICO_Method_buyTokensInternal(
               self, sender, value, blocknum, timestamp, Init_sol_bool_t(0),
               origin, Init_sol_address_t((func_user_buyer).v),
               Init_sol_uint256_t((func_user_remainingCents).v),
               Init_sol_uint256_t((func_user_txHash).v)))
              .v);
    }
  } else {
    { return Init_sol_uint256_t((func_user_remainingCents).v); }
  }
}
sol_uint256_t ICO_Method_buyTokensByOptions(
    struct ICO *self, sol_address_t sender, sol_uint256_t value,
    sol_uint256_t blocknum, sol_uint256_t timestamp, sol_bool_t paid,
    sol_address_t origin, sol_address_t func_model_buyer,
    sol_uint256_t func_model_usdCents, sol_uint256_t func_model_txHash) {
  sol_uint256_t func_model_rv;
  sol_require(((sender).v) == ((self->user_gvAgent).v), 0);
  (func_model_rv) = (ICO_Method_1_buyTokensByOptions(
      self, sender, value, blocknum, timestamp, Init_sol_bool_t(0), origin,
      func_model_buyer, func_model_usdCents, func_model_txHash));
  return func_model_rv;
}
void ICO_Method_1_buyOptions(struct ICO *self, sol_address_t sender,
                             sol_uint256_t value, sol_uint256_t blocknum,
                             sol_uint256_t timestamp, sol_bool_t paid,
                             sol_address_t origin,
                             sol_address_t func_user_buyer,
                             sol_uint256_t func_user_usdCents,
                             sol_uint256_t func_user_txHash) {
  sol_require(!((self->user_isPaused).v), 0);
  sol_require(((self->user_icoState).v) == (1), 0);
  GVOptionProgram_Method_buyOptions(
      &(self->user_optionProgram), (self)->model_address, Init_sol_uint256_t(0),
      blocknum, timestamp, Init_sol_bool_t(1), origin,
      Init_sol_address_t((func_user_buyer).v),
      Init_sol_uint256_t((func_user_usdCents).v),
      Init_sol_uint256_t((func_user_txHash).v));
}
void ICO_Method_buyOptions(struct ICO *self, sol_address_t sender,
                           sol_uint256_t value, sol_uint256_t blocknum,
                           sol_uint256_t timestamp, sol_bool_t paid,
                           sol_address_t origin, sol_address_t func_model_buyer,
                           sol_uint256_t func_model_usdCents,
                           sol_uint256_t func_model_txHash) {
  sol_require(((sender).v) == ((self->user_gvAgent).v), 0);
  ICO_Method_1_buyOptions(self, sender, value, blocknum, timestamp,
                          Init_sol_bool_t(0), origin, func_model_buyer,
                          func_model_usdCents, func_model_txHash);
}
void ICO_Method_bad(struct ICO *self, sol_address_t sender, sol_uint256_t value,
                    sol_uint256_t blocknum, sol_uint256_t timestamp,
                    sol_bool_t paid, sol_address_t origin,
                    sol_address_t func_user___from,
                    sol_address_t func_user___to,
                    sol_uint256_t func_user___value) {
  (GVToken_Method_transferFrom(&(self->user_gvToken), (self)->model_address,
                               Init_sol_uint256_t(0), blocknum, timestamp,
                               Init_sol_bool_t(1), origin,
                               Init_sol_address_t((func_user___from).v),
                               Init_sol_address_t((func_user___to).v),
                               Init_sol_uint256_t((func_user___value).v)))
      .v;
}
sol_uint256_t ICO_Method_buyTokensInternal(
    struct ICO *self, sol_address_t sender, sol_uint256_t value,
    sol_uint256_t blocknum, sol_uint256_t timestamp, sol_bool_t paid,
    sol_address_t origin, sol_address_t func_user_buyer,
    sol_uint256_t func_user_usdCents, sol_uint256_t func_user_txHash) {
  sol_require(((func_user_usdCents).v) > (0), 0);
  sol_uint256_t func_user_tokens = Init_sol_uint256_t((func_user_usdCents).v);
  sol_require((((self->user_tokensSold).v) + ((func_user_tokens).v)) <=
                  (330000000000000000),
              0);
  ((self->user_tokensSold).v) =
      (((self->user_tokensSold).v) + ((func_user_tokens).v));
  GVToken_Method_mint(&(self->user_gvToken), (self)->model_address,
                      Init_sol_uint256_t(0), blocknum, timestamp,
                      Init_sol_bool_t(1), origin,
                      Init_sol_address_t((func_user_buyer).v),
                      Init_sol_uint256_t((func_user_tokens).v));
  {
    (func_user_buyer).v;
    (func_user_tokens).v;
    (func_user_txHash).v;
    sol_emit("BuyTokens(buyer, tokens, txHash)");
  }
  { return Init_sol_uint256_t(0); }
}
struct Map_2 ZeroInit_Map_2(void) {
  struct Map_2 tmp;
  ((tmp).sum) = (Init_sol_uint256_t(0));
  ((tmp).data_0_0) = (Init_sol_uint256_t(0));
  ((tmp).data_0_1) = (Init_sol_uint256_t(0));
  ((tmp).data_0_2) = (Init_sol_uint256_t(0));
  ((tmp).data_0_3) = (Init_sol_uint256_t(0));
  ((tmp).data_0_4) = (Init_sol_uint256_t(0));
  ((tmp).data_0_5) = (Init_sol_uint256_t(0));
  ((tmp).data_0_6) = (Init_sol_uint256_t(0));
  ((tmp).data_0_7) = (Init_sol_uint256_t(0));
  ((tmp).data_0_8) = (Init_sol_uint256_t(0));
  ((tmp).data_0_9) = (Init_sol_uint256_t(0));
  ((tmp).data_0_10) = (Init_sol_uint256_t(0));
  ((tmp).data_0_11) = (Init_sol_uint256_t(0));
  ((tmp).data_1_0) = (Init_sol_uint256_t(0));
  ((tmp).data_1_1) = (Init_sol_uint256_t(0));
  ((tmp).data_1_2) = (Init_sol_uint256_t(0));
  ((tmp).data_1_3) = (Init_sol_uint256_t(0));
  ((tmp).data_1_4) = (Init_sol_uint256_t(0));
  ((tmp).data_1_5) = (Init_sol_uint256_t(0));
  ((tmp).data_1_6) = (Init_sol_uint256_t(0));
  ((tmp).data_1_7) = (Init_sol_uint256_t(0));
  ((tmp).data_1_8) = (Init_sol_uint256_t(0));
  ((tmp).data_1_9) = (Init_sol_uint256_t(0));
  ((tmp).data_1_10) = (Init_sol_uint256_t(0));
  ((tmp).data_1_11) = (Init_sol_uint256_t(0));
  ((tmp).data_2_0) = (Init_sol_uint256_t(0));
  ((tmp).data_2_1) = (Init_sol_uint256_t(0));
  ((tmp).data_2_2) = (Init_sol_uint256_t(0));
  ((tmp).data_2_3) = (Init_sol_uint256_t(0));
  ((tmp).data_2_4) = (Init_sol_uint256_t(0));
  ((tmp).data_2_5) = (Init_sol_uint256_t(0));
  ((tmp).data_2_6) = (Init_sol_uint256_t(0));
  ((tmp).data_2_7) = (Init_sol_uint256_t(0));
  ((tmp).data_2_8) = (Init_sol_uint256_t(0));
  ((tmp).data_2_9) = (Init_sol_uint256_t(0));
  ((tmp).data_2_10) = (Init_sol_uint256_t(0));
  ((tmp).data_2_11) = (Init_sol_uint256_t(0));
  ((tmp).data_3_0) = (Init_sol_uint256_t(0));
  ((tmp).data_3_1) = (Init_sol_uint256_t(0));
  ((tmp).data_3_2) = (Init_sol_uint256_t(0));
  ((tmp).data_3_3) = (Init_sol_uint256_t(0));
  ((tmp).data_3_4) = (Init_sol_uint256_t(0));
  ((tmp).data_3_5) = (Init_sol_uint256_t(0));
  ((tmp).data_3_6) = (Init_sol_uint256_t(0));
  ((tmp).data_3_7) = (Init_sol_uint256_t(0));
  ((tmp).data_3_8) = (Init_sol_uint256_t(0));
  ((tmp).data_3_9) = (Init_sol_uint256_t(0));
  ((tmp).data_3_10) = (Init_sol_uint256_t(0));
  ((tmp).data_3_11) = (Init_sol_uint256_t(0));
  ((tmp).data_4_0) = (Init_sol_uint256_t(0));
  ((tmp).data_4_1) = (Init_sol_uint256_t(0));
  ((tmp).data_4_2) = (Init_sol_uint256_t(0));
  ((tmp).data_4_3) = (Init_sol_uint256_t(0));
  ((tmp).data_4_4) = (Init_sol_uint256_t(0));
  ((tmp).data_4_5) = (Init_sol_uint256_t(0));
  ((tmp).data_4_6) = (Init_sol_uint256_t(0));
  ((tmp).data_4_7) = (Init_sol_uint256_t(0));
  ((tmp).data_4_8) = (Init_sol_uint256_t(0));
  ((tmp).data_4_9) = (Init_sol_uint256_t(0));
  ((tmp).data_4_10) = (Init_sol_uint256_t(0));
  ((tmp).data_4_11) = (Init_sol_uint256_t(0));
  ((tmp).data_5_0) = (Init_sol_uint256_t(0));
  ((tmp).data_5_1) = (Init_sol_uint256_t(0));
  ((tmp).data_5_2) = (Init_sol_uint256_t(0));
  ((tmp).data_5_3) = (Init_sol_uint256_t(0));
  ((tmp).data_5_4) = (Init_sol_uint256_t(0));
  ((tmp).data_5_5) = (Init_sol_uint256_t(0));
  ((tmp).data_5_6) = (Init_sol_uint256_t(0));
  ((tmp).data_5_7) = (Init_sol_uint256_t(0));
  ((tmp).data_5_8) = (Init_sol_uint256_t(0));
  ((tmp).data_5_9) = (Init_sol_uint256_t(0));
  ((tmp).data_5_10) = (Init_sol_uint256_t(0));
  ((tmp).data_5_11) = (Init_sol_uint256_t(0));
  ((tmp).data_6_0) = (Init_sol_uint256_t(0));
  ((tmp).data_6_1) = (Init_sol_uint256_t(0));
  ((tmp).data_6_2) = (Init_sol_uint256_t(0));
  ((tmp).data_6_3) = (Init_sol_uint256_t(0));
  ((tmp).data_6_4) = (Init_sol_uint256_t(0));
  ((tmp).data_6_5) = (Init_sol_uint256_t(0));
  ((tmp).data_6_6) = (Init_sol_uint256_t(0));
  ((tmp).data_6_7) = (Init_sol_uint256_t(0));
  ((tmp).data_6_8) = (Init_sol_uint256_t(0));
  ((tmp).data_6_9) = (Init_sol_uint256_t(0));
  ((tmp).data_6_10) = (Init_sol_uint256_t(0));
  ((tmp).data_6_11) = (Init_sol_uint256_t(0));
  ((tmp).data_7_0) = (Init_sol_uint256_t(0));
  ((tmp).data_7_1) = (Init_sol_uint256_t(0));
  ((tmp).data_7_2) = (Init_sol_uint256_t(0));
  ((tmp).data_7_3) = (Init_sol_uint256_t(0));
  ((tmp).data_7_4) = (Init_sol_uint256_t(0));
  ((tmp).data_7_5) = (Init_sol_uint256_t(0));
  ((tmp).data_7_6) = (Init_sol_uint256_t(0));
  ((tmp).data_7_7) = (Init_sol_uint256_t(0));
  ((tmp).data_7_8) = (Init_sol_uint256_t(0));
  ((tmp).data_7_9) = (Init_sol_uint256_t(0));
  ((tmp).data_7_10) = (Init_sol_uint256_t(0));
  ((tmp).data_7_11) = (Init_sol_uint256_t(0));
  ((tmp).data_8_0) = (Init_sol_uint256_t(0));
  ((tmp).data_8_1) = (Init_sol_uint256_t(0));
  ((tmp).data_8_2) = (Init_sol_uint256_t(0));
  ((tmp).data_8_3) = (Init_sol_uint256_t(0));
  ((tmp).data_8_4) = (Init_sol_uint256_t(0));
  ((tmp).data_8_5) = (Init_sol_uint256_t(0));
  ((tmp).data_8_6) = (Init_sol_uint256_t(0));
  ((tmp).data_8_7) = (Init_sol_uint256_t(0));
  ((tmp).data_8_8) = (Init_sol_uint256_t(0));
  ((tmp).data_8_9) = (Init_sol_uint256_t(0));
  ((tmp).data_8_10) = (Init_sol_uint256_t(0));
  ((tmp).data_8_11) = (Init_sol_uint256_t(0));
  ((tmp).data_9_0) = (Init_sol_uint256_t(0));
  ((tmp).data_9_1) = (Init_sol_uint256_t(0));
  ((tmp).data_9_2) = (Init_sol_uint256_t(0));
  ((tmp).data_9_3) = (Init_sol_uint256_t(0));
  ((tmp).data_9_4) = (Init_sol_uint256_t(0));
  ((tmp).data_9_5) = (Init_sol_uint256_t(0));
  ((tmp).data_9_6) = (Init_sol_uint256_t(0));
  ((tmp).data_9_7) = (Init_sol_uint256_t(0));
  ((tmp).data_9_8) = (Init_sol_uint256_t(0));
  ((tmp).data_9_9) = (Init_sol_uint256_t(0));
  ((tmp).data_9_10) = (Init_sol_uint256_t(0));
  ((tmp).data_9_11) = (Init_sol_uint256_t(0));
  ((tmp).data_10_0) = (Init_sol_uint256_t(0));
  ((tmp).data_10_1) = (Init_sol_uint256_t(0));
  ((tmp).data_10_2) = (Init_sol_uint256_t(0));
  ((tmp).data_10_3) = (Init_sol_uint256_t(0));
  ((tmp).data_10_4) = (Init_sol_uint256_t(0));
  ((tmp).data_10_5) = (Init_sol_uint256_t(0));
  ((tmp).data_10_6) = (Init_sol_uint256_t(0));
  ((tmp).data_10_7) = (Init_sol_uint256_t(0));
  ((tmp).data_10_8) = (Init_sol_uint256_t(0));
  ((tmp).data_10_9) = (Init_sol_uint256_t(0));
  ((tmp).data_10_10) = (Init_sol_uint256_t(0));
  ((tmp).data_10_11) = (Init_sol_uint256_t(0));
  ((tmp).data_11_0) = (Init_sol_uint256_t(0));
  ((tmp).data_11_1) = (Init_sol_uint256_t(0));
  ((tmp).data_11_2) = (Init_sol_uint256_t(0));
  ((tmp).data_11_3) = (Init_sol_uint256_t(0));
  ((tmp).data_11_4) = (Init_sol_uint256_t(0));
  ((tmp).data_11_5) = (Init_sol_uint256_t(0));
  ((tmp).data_11_6) = (Init_sol_uint256_t(0));
  ((tmp).data_11_7) = (Init_sol_uint256_t(0));
  ((tmp).data_11_8) = (Init_sol_uint256_t(0));
  ((tmp).data_11_9) = (Init_sol_uint256_t(0));
  ((tmp).data_11_10) = (Init_sol_uint256_t(0));
  ((tmp).data_11_11) = (Init_sol_uint256_t(0));
  return tmp;
}
sol_uint256_t Read_Map_2(struct Map_2 *arr, sol_address_t key_0,
                         sol_address_t key_1) {
  {
    sol_assert((12) >= ((key_0).v),
               "Model failure, mapping key out of bounds.");
    sol_assert((12) >= ((key_1).v),
               "Model failure, mapping key out of bounds.");
    if ((11) == ((key_0).v)) {
      if ((11) == ((key_1).v))
        return (arr)->data_11_11;
      else if ((10) == ((key_1).v))
        return (arr)->data_11_10;
      else if ((9) == ((key_1).v))
        return (arr)->data_11_9;
      else if ((8) == ((key_1).v))
        return (arr)->data_11_8;
      else if ((7) == ((key_1).v))
        return (arr)->data_11_7;
      else if ((6) == ((key_1).v))
        return (arr)->data_11_6;
      else if ((5) == ((key_1).v))
        return (arr)->data_11_5;
      else if ((4) == ((key_1).v))
        return (arr)->data_11_4;
      else if ((3) == ((key_1).v))
        return (arr)->data_11_3;
      else if ((2) == ((key_1).v))
        return (arr)->data_11_2;
      else if ((1) == ((key_1).v))
        return (arr)->data_11_1;
      else if ((0) == ((key_1).v))
        return (arr)->data_11_0;
    } else if ((10) == ((key_0).v)) {
      if ((11) == ((key_1).v))
        return (arr)->data_10_11;
      else if ((10) == ((key_1).v))
        return (arr)->data_10_10;
      else if ((9) == ((key_1).v))
        return (arr)->data_10_9;
      else if ((8) == ((key_1).v))
        return (arr)->data_10_8;
      else if ((7) == ((key_1).v))
        return (arr)->data_10_7;
      else if ((6) == ((key_1).v))
        return (arr)->data_10_6;
      else if ((5) == ((key_1).v))
        return (arr)->data_10_5;
      else if ((4) == ((key_1).v))
        return (arr)->data_10_4;
      else if ((3) == ((key_1).v))
        return (arr)->data_10_3;
      else if ((2) == ((key_1).v))
        return (arr)->data_10_2;
      else if ((1) == ((key_1).v))
        return (arr)->data_10_1;
      else if ((0) == ((key_1).v))
        return (arr)->data_10_0;
    } else if ((9) == ((key_0).v)) {
      if ((11) == ((key_1).v))
        return (arr)->data_9_11;
      else if ((10) == ((key_1).v))
        return (arr)->data_9_10;
      else if ((9) == ((key_1).v))
        return (arr)->data_9_9;
      else if ((8) == ((key_1).v))
        return (arr)->data_9_8;
      else if ((7) == ((key_1).v))
        return (arr)->data_9_7;
      else if ((6) == ((key_1).v))
        return (arr)->data_9_6;
      else if ((5) == ((key_1).v))
        return (arr)->data_9_5;
      else if ((4) == ((key_1).v))
        return (arr)->data_9_4;
      else if ((3) == ((key_1).v))
        return (arr)->data_9_3;
      else if ((2) == ((key_1).v))
        return (arr)->data_9_2;
      else if ((1) == ((key_1).v))
        return (arr)->data_9_1;
      else if ((0) == ((key_1).v))
        return (arr)->data_9_0;
    } else if ((8) == ((key_0).v)) {
      if ((11) == ((key_1).v))
        return (arr)->data_8_11;
      else if ((10) == ((key_1).v))
        return (arr)->data_8_10;
      else if ((9) == ((key_1).v))
        return (arr)->data_8_9;
      else if ((8) == ((key_1).v))
        return (arr)->data_8_8;
      else if ((7) == ((key_1).v))
        return (arr)->data_8_7;
      else if ((6) == ((key_1).v))
        return (arr)->data_8_6;
      else if ((5) == ((key_1).v))
        return (arr)->data_8_5;
      else if ((4) == ((key_1).v))
        return (arr)->data_8_4;
      else if ((3) == ((key_1).v))
        return (arr)->data_8_3;
      else if ((2) == ((key_1).v))
        return (arr)->data_8_2;
      else if ((1) == ((key_1).v))
        return (arr)->data_8_1;
      else if ((0) == ((key_1).v))
        return (arr)->data_8_0;
    } else if ((7) == ((key_0).v)) {
      if ((11) == ((key_1).v))
        return (arr)->data_7_11;
      else if ((10) == ((key_1).v))
        return (arr)->data_7_10;
      else if ((9) == ((key_1).v))
        return (arr)->data_7_9;
      else if ((8) == ((key_1).v))
        return (arr)->data_7_8;
      else if ((7) == ((key_1).v))
        return (arr)->data_7_7;
      else if ((6) == ((key_1).v))
        return (arr)->data_7_6;
      else if ((5) == ((key_1).v))
        return (arr)->data_7_5;
      else if ((4) == ((key_1).v))
        return (arr)->data_7_4;
      else if ((3) == ((key_1).v))
        return (arr)->data_7_3;
      else if ((2) == ((key_1).v))
        return (arr)->data_7_2;
      else if ((1) == ((key_1).v))
        return (arr)->data_7_1;
      else if ((0) == ((key_1).v))
        return (arr)->data_7_0;
    } else if ((6) == ((key_0).v)) {
      if ((11) == ((key_1).v))
        return (arr)->data_6_11;
      else if ((10) == ((key_1).v))
        return (arr)->data_6_10;
      else if ((9) == ((key_1).v))
        return (arr)->data_6_9;
      else if ((8) == ((key_1).v))
        return (arr)->data_6_8;
      else if ((7) == ((key_1).v))
        return (arr)->data_6_7;
      else if ((6) == ((key_1).v))
        return (arr)->data_6_6;
      else if ((5) == ((key_1).v))
        return (arr)->data_6_5;
      else if ((4) == ((key_1).v))
        return (arr)->data_6_4;
      else if ((3) == ((key_1).v))
        return (arr)->data_6_3;
      else if ((2) == ((key_1).v))
        return (arr)->data_6_2;
      else if ((1) == ((key_1).v))
        return (arr)->data_6_1;
      else if ((0) == ((key_1).v))
        return (arr)->data_6_0;
    } else if ((5) == ((key_0).v)) {
      if ((11) == ((key_1).v))
        return (arr)->data_5_11;
      else if ((10) == ((key_1).v))
        return (arr)->data_5_10;
      else if ((9) == ((key_1).v))
        return (arr)->data_5_9;
      else if ((8) == ((key_1).v))
        return (arr)->data_5_8;
      else if ((7) == ((key_1).v))
        return (arr)->data_5_7;
      else if ((6) == ((key_1).v))
        return (arr)->data_5_6;
      else if ((5) == ((key_1).v))
        return (arr)->data_5_5;
      else if ((4) == ((key_1).v))
        return (arr)->data_5_4;
      else if ((3) == ((key_1).v))
        return (arr)->data_5_3;
      else if ((2) == ((key_1).v))
        return (arr)->data_5_2;
      else if ((1) == ((key_1).v))
        return (arr)->data_5_1;
      else if ((0) == ((key_1).v))
        return (arr)->data_5_0;
    } else if ((4) == ((key_0).v)) {
      if ((11) == ((key_1).v))
        return (arr)->data_4_11;
      else if ((10) == ((key_1).v))
        return (arr)->data_4_10;
      else if ((9) == ((key_1).v))
        return (arr)->data_4_9;
      else if ((8) == ((key_1).v))
        return (arr)->data_4_8;
      else if ((7) == ((key_1).v))
        return (arr)->data_4_7;
      else if ((6) == ((key_1).v))
        return (arr)->data_4_6;
      else if ((5) == ((key_1).v))
        return (arr)->data_4_5;
      else if ((4) == ((key_1).v))
        return (arr)->data_4_4;
      else if ((3) == ((key_1).v))
        return (arr)->data_4_3;
      else if ((2) == ((key_1).v))
        return (arr)->data_4_2;
      else if ((1) == ((key_1).v))
        return (arr)->data_4_1;
      else if ((0) == ((key_1).v))
        return (arr)->data_4_0;
    } else if ((3) == ((key_0).v)) {
      if ((11) == ((key_1).v))
        return (arr)->data_3_11;
      else if ((10) == ((key_1).v))
        return (arr)->data_3_10;
      else if ((9) == ((key_1).v))
        return (arr)->data_3_9;
      else if ((8) == ((key_1).v))
        return (arr)->data_3_8;
      else if ((7) == ((key_1).v))
        return (arr)->data_3_7;
      else if ((6) == ((key_1).v))
        return (arr)->data_3_6;
      else if ((5) == ((key_1).v))
        return (arr)->data_3_5;
      else if ((4) == ((key_1).v))
        return (arr)->data_3_4;
      else if ((3) == ((key_1).v))
        return (arr)->data_3_3;
      else if ((2) == ((key_1).v))
        return (arr)->data_3_2;
      else if ((1) == ((key_1).v))
        return (arr)->data_3_1;
      else if ((0) == ((key_1).v))
        return (arr)->data_3_0;
    } else if ((2) == ((key_0).v)) {
      if ((11) == ((key_1).v))
        return (arr)->data_2_11;
      else if ((10) == ((key_1).v))
        return (arr)->data_2_10;
      else if ((9) == ((key_1).v))
        return (arr)->data_2_9;
      else if ((8) == ((key_1).v))
        return (arr)->data_2_8;
      else if ((7) == ((key_1).v))
        return (arr)->data_2_7;
      else if ((6) == ((key_1).v))
        return (arr)->data_2_6;
      else if ((5) == ((key_1).v))
        return (arr)->data_2_5;
      else if ((4) == ((key_1).v))
        return (arr)->data_2_4;
      else if ((3) == ((key_1).v))
        return (arr)->data_2_3;
      else if ((2) == ((key_1).v))
        return (arr)->data_2_2;
      else if ((1) == ((key_1).v))
        return (arr)->data_2_1;
      else if ((0) == ((key_1).v))
        return (arr)->data_2_0;
    } else if ((1) == ((key_0).v)) {
      if ((11) == ((key_1).v))
        return (arr)->data_1_11;
      else if ((10) == ((key_1).v))
        return (arr)->data_1_10;
      else if ((9) == ((key_1).v))
        return (arr)->data_1_9;
      else if ((8) == ((key_1).v))
        return (arr)->data_1_8;
      else if ((7) == ((key_1).v))
        return (arr)->data_1_7;
      else if ((6) == ((key_1).v))
        return (arr)->data_1_6;
      else if ((5) == ((key_1).v))
        return (arr)->data_1_5;
      else if ((4) == ((key_1).v))
        return (arr)->data_1_4;
      else if ((3) == ((key_1).v))
        return (arr)->data_1_3;
      else if ((2) == ((key_1).v))
        return (arr)->data_1_2;
      else if ((1) == ((key_1).v))
        return (arr)->data_1_1;
      else if ((0) == ((key_1).v))
        return (arr)->data_1_0;
    } else if ((0) == ((key_0).v)) {
      if ((11) == ((key_1).v))
        return (arr)->data_0_11;
      else if ((10) == ((key_1).v))
        return (arr)->data_0_10;
      else if ((9) == ((key_1).v))
        return (arr)->data_0_9;
      else if ((8) == ((key_1).v))
        return (arr)->data_0_8;
      else if ((7) == ((key_1).v))
        return (arr)->data_0_7;
      else if ((6) == ((key_1).v))
        return (arr)->data_0_6;
      else if ((5) == ((key_1).v))
        return (arr)->data_0_5;
      else if ((4) == ((key_1).v))
        return (arr)->data_0_4;
      else if ((3) == ((key_1).v))
        return (arr)->data_0_3;
      else if ((2) == ((key_1).v))
        return (arr)->data_0_2;
      else if ((1) == ((key_1).v))
        return (arr)->data_0_1;
      else if ((0) == ((key_1).v))
        return (arr)->data_0_0;
    }
  }
  return Init_sol_uint256_t(0);
}
void Write_Map_2(struct Map_2 *arr, sol_address_t key_0, sol_address_t key_1,
                 sol_uint256_t dat) {
  {
    sol_assert((12) >= ((key_0).v),
               "Model failure, mapping key out of bounds.");
    sol_assert((12) >= ((key_1).v),
               "Model failure, mapping key out of bounds.");
    if ((11) == ((key_0).v)) {
      if ((11) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_11_11).v);
        ((arr)->data_11_11) = (dat);
      } else if ((10) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_11_10).v);
        ((arr)->data_11_10) = (dat);
      } else if ((9) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_11_9).v);
        ((arr)->data_11_9) = (dat);
      } else if ((8) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_11_8).v);
        ((arr)->data_11_8) = (dat);
      } else if ((7) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_11_7).v);
        ((arr)->data_11_7) = (dat);
      } else if ((6) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_11_6).v);
        ((arr)->data_11_6) = (dat);
      } else if ((5) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_11_5).v);
        ((arr)->data_11_5) = (dat);
      } else if ((4) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_11_4).v);
        ((arr)->data_11_4) = (dat);
      } else if ((3) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_11_3).v);
        ((arr)->data_11_3) = (dat);
      } else if ((2) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_11_2).v);
        ((arr)->data_11_2) = (dat);
      } else if ((1) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_11_1).v);
        ((arr)->data_11_1) = (dat);
      } else if ((0) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_11_0).v);
        ((arr)->data_11_0) = (dat);
      }
    } else if ((10) == ((key_0).v)) {
      if ((11) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_10_11).v);
        ((arr)->data_10_11) = (dat);
      } else if ((10) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_10_10).v);
        ((arr)->data_10_10) = (dat);
      } else if ((9) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_10_9).v);
        ((arr)->data_10_9) = (dat);
      } else if ((8) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_10_8).v);
        ((arr)->data_10_8) = (dat);
      } else if ((7) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_10_7).v);
        ((arr)->data_10_7) = (dat);
      } else if ((6) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_10_6).v);
        ((arr)->data_10_6) = (dat);
      } else if ((5) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_10_5).v);
        ((arr)->data_10_5) = (dat);
      } else if ((4) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_10_4).v);
        ((arr)->data_10_4) = (dat);
      } else if ((3) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_10_3).v);
        ((arr)->data_10_3) = (dat);
      } else if ((2) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_10_2).v);
        ((arr)->data_10_2) = (dat);
      } else if ((1) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_10_1).v);
        ((arr)->data_10_1) = (dat);
      } else if ((0) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_10_0).v);
        ((arr)->data_10_0) = (dat);
      }
    } else if ((9) == ((key_0).v)) {
      if ((11) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_9_11).v);
        ((arr)->data_9_11) = (dat);
      } else if ((10) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_9_10).v);
        ((arr)->data_9_10) = (dat);
      } else if ((9) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_9_9).v);
        ((arr)->data_9_9) = (dat);
      } else if ((8) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_9_8).v);
        ((arr)->data_9_8) = (dat);
      } else if ((7) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_9_7).v);
        ((arr)->data_9_7) = (dat);
      } else if ((6) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_9_6).v);
        ((arr)->data_9_6) = (dat);
      } else if ((5) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_9_5).v);
        ((arr)->data_9_5) = (dat);
      } else if ((4) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_9_4).v);
        ((arr)->data_9_4) = (dat);
      } else if ((3) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_9_3).v);
        ((arr)->data_9_3) = (dat);
      } else if ((2) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_9_2).v);
        ((arr)->data_9_2) = (dat);
      } else if ((1) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_9_1).v);
        ((arr)->data_9_1) = (dat);
      } else if ((0) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_9_0).v);
        ((arr)->data_9_0) = (dat);
      }
    } else if ((8) == ((key_0).v)) {
      if ((11) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_8_11).v);
        ((arr)->data_8_11) = (dat);
      } else if ((10) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_8_10).v);
        ((arr)->data_8_10) = (dat);
      } else if ((9) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_8_9).v);
        ((arr)->data_8_9) = (dat);
      } else if ((8) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_8_8).v);
        ((arr)->data_8_8) = (dat);
      } else if ((7) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_8_7).v);
        ((arr)->data_8_7) = (dat);
      } else if ((6) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_8_6).v);
        ((arr)->data_8_6) = (dat);
      } else if ((5) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_8_5).v);
        ((arr)->data_8_5) = (dat);
      } else if ((4) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_8_4).v);
        ((arr)->data_8_4) = (dat);
      } else if ((3) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_8_3).v);
        ((arr)->data_8_3) = (dat);
      } else if ((2) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_8_2).v);
        ((arr)->data_8_2) = (dat);
      } else if ((1) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_8_1).v);
        ((arr)->data_8_1) = (dat);
      } else if ((0) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_8_0).v);
        ((arr)->data_8_0) = (dat);
      }
    } else if ((7) == ((key_0).v)) {
      if ((11) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_7_11).v);
        ((arr)->data_7_11) = (dat);
      } else if ((10) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_7_10).v);
        ((arr)->data_7_10) = (dat);
      } else if ((9) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_7_9).v);
        ((arr)->data_7_9) = (dat);
      } else if ((8) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_7_8).v);
        ((arr)->data_7_8) = (dat);
      } else if ((7) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_7_7).v);
        ((arr)->data_7_7) = (dat);
      } else if ((6) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_7_6).v);
        ((arr)->data_7_6) = (dat);
      } else if ((5) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_7_5).v);
        ((arr)->data_7_5) = (dat);
      } else if ((4) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_7_4).v);
        ((arr)->data_7_4) = (dat);
      } else if ((3) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_7_3).v);
        ((arr)->data_7_3) = (dat);
      } else if ((2) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_7_2).v);
        ((arr)->data_7_2) = (dat);
      } else if ((1) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_7_1).v);
        ((arr)->data_7_1) = (dat);
      } else if ((0) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_7_0).v);
        ((arr)->data_7_0) = (dat);
      }
    } else if ((6) == ((key_0).v)) {
      if ((11) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_6_11).v);
        ((arr)->data_6_11) = (dat);
      } else if ((10) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_6_10).v);
        ((arr)->data_6_10) = (dat);
      } else if ((9) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_6_9).v);
        ((arr)->data_6_9) = (dat);
      } else if ((8) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_6_8).v);
        ((arr)->data_6_8) = (dat);
      } else if ((7) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_6_7).v);
        ((arr)->data_6_7) = (dat);
      } else if ((6) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_6_6).v);
        ((arr)->data_6_6) = (dat);
      } else if ((5) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_6_5).v);
        ((arr)->data_6_5) = (dat);
      } else if ((4) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_6_4).v);
        ((arr)->data_6_4) = (dat);
      } else if ((3) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_6_3).v);
        ((arr)->data_6_3) = (dat);
      } else if ((2) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_6_2).v);
        ((arr)->data_6_2) = (dat);
      } else if ((1) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_6_1).v);
        ((arr)->data_6_1) = (dat);
      } else if ((0) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_6_0).v);
        ((arr)->data_6_0) = (dat);
      }
    } else if ((5) == ((key_0).v)) {
      if ((11) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_5_11).v);
        ((arr)->data_5_11) = (dat);
      } else if ((10) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_5_10).v);
        ((arr)->data_5_10) = (dat);
      } else if ((9) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_5_9).v);
        ((arr)->data_5_9) = (dat);
      } else if ((8) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_5_8).v);
        ((arr)->data_5_8) = (dat);
      } else if ((7) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_5_7).v);
        ((arr)->data_5_7) = (dat);
      } else if ((6) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_5_6).v);
        ((arr)->data_5_6) = (dat);
      } else if ((5) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_5_5).v);
        ((arr)->data_5_5) = (dat);
      } else if ((4) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_5_4).v);
        ((arr)->data_5_4) = (dat);
      } else if ((3) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_5_3).v);
        ((arr)->data_5_3) = (dat);
      } else if ((2) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_5_2).v);
        ((arr)->data_5_2) = (dat);
      } else if ((1) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_5_1).v);
        ((arr)->data_5_1) = (dat);
      } else if ((0) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_5_0).v);
        ((arr)->data_5_0) = (dat);
      }
    } else if ((4) == ((key_0).v)) {
      if ((11) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_4_11).v);
        ((arr)->data_4_11) = (dat);
      } else if ((10) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_4_10).v);
        ((arr)->data_4_10) = (dat);
      } else if ((9) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_4_9).v);
        ((arr)->data_4_9) = (dat);
      } else if ((8) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_4_8).v);
        ((arr)->data_4_8) = (dat);
      } else if ((7) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_4_7).v);
        ((arr)->data_4_7) = (dat);
      } else if ((6) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_4_6).v);
        ((arr)->data_4_6) = (dat);
      } else if ((5) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_4_5).v);
        ((arr)->data_4_5) = (dat);
      } else if ((4) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_4_4).v);
        ((arr)->data_4_4) = (dat);
      } else if ((3) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_4_3).v);
        ((arr)->data_4_3) = (dat);
      } else if ((2) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_4_2).v);
        ((arr)->data_4_2) = (dat);
      } else if ((1) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_4_1).v);
        ((arr)->data_4_1) = (dat);
      } else if ((0) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_4_0).v);
        ((arr)->data_4_0) = (dat);
      }
    } else if ((3) == ((key_0).v)) {
      if ((11) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_3_11).v);
        ((arr)->data_3_11) = (dat);
      } else if ((10) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_3_10).v);
        ((arr)->data_3_10) = (dat);
      } else if ((9) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_3_9).v);
        ((arr)->data_3_9) = (dat);
      } else if ((8) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_3_8).v);
        ((arr)->data_3_8) = (dat);
      } else if ((7) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_3_7).v);
        ((arr)->data_3_7) = (dat);
      } else if ((6) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_3_6).v);
        ((arr)->data_3_6) = (dat);
      } else if ((5) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_3_5).v);
        ((arr)->data_3_5) = (dat);
      } else if ((4) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_3_4).v);
        ((arr)->data_3_4) = (dat);
      } else if ((3) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_3_3).v);
        ((arr)->data_3_3) = (dat);
      } else if ((2) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_3_2).v);
        ((arr)->data_3_2) = (dat);
      } else if ((1) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_3_1).v);
        ((arr)->data_3_1) = (dat);
      } else if ((0) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_3_0).v);
        ((arr)->data_3_0) = (dat);
      }
    } else if ((2) == ((key_0).v)) {
      if ((11) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_2_11).v);
        ((arr)->data_2_11) = (dat);
      } else if ((10) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_2_10).v);
        ((arr)->data_2_10) = (dat);
      } else if ((9) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_2_9).v);
        ((arr)->data_2_9) = (dat);
      } else if ((8) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_2_8).v);
        ((arr)->data_2_8) = (dat);
      } else if ((7) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_2_7).v);
        ((arr)->data_2_7) = (dat);
      } else if ((6) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_2_6).v);
        ((arr)->data_2_6) = (dat);
      } else if ((5) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_2_5).v);
        ((arr)->data_2_5) = (dat);
      } else if ((4) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_2_4).v);
        ((arr)->data_2_4) = (dat);
      } else if ((3) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_2_3).v);
        ((arr)->data_2_3) = (dat);
      } else if ((2) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_2_2).v);
        ((arr)->data_2_2) = (dat);
      } else if ((1) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_2_1).v);
        ((arr)->data_2_1) = (dat);
      } else if ((0) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_2_0).v);
        ((arr)->data_2_0) = (dat);
      }
    } else if ((1) == ((key_0).v)) {
      if ((11) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_1_11).v);
        ((arr)->data_1_11) = (dat);
      } else if ((10) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_1_10).v);
        ((arr)->data_1_10) = (dat);
      } else if ((9) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_1_9).v);
        ((arr)->data_1_9) = (dat);
      } else if ((8) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_1_8).v);
        ((arr)->data_1_8) = (dat);
      } else if ((7) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_1_7).v);
        ((arr)->data_1_7) = (dat);
      } else if ((6) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_1_6).v);
        ((arr)->data_1_6) = (dat);
      } else if ((5) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_1_5).v);
        ((arr)->data_1_5) = (dat);
      } else if ((4) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_1_4).v);
        ((arr)->data_1_4) = (dat);
      } else if ((3) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_1_3).v);
        ((arr)->data_1_3) = (dat);
      } else if ((2) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_1_2).v);
        ((arr)->data_1_2) = (dat);
      } else if ((1) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_1_1).v);
        ((arr)->data_1_1) = (dat);
      } else if ((0) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_1_0).v);
        ((arr)->data_1_0) = (dat);
      }
    } else if ((0) == ((key_0).v)) {
      if ((11) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_0_11).v);
        ((arr)->data_0_11) = (dat);
      } else if ((10) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_0_10).v);
        ((arr)->data_0_10) = (dat);
      } else if ((9) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_0_9).v);
        ((arr)->data_0_9) = (dat);
      } else if ((8) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_0_8).v);
        ((arr)->data_0_8) = (dat);
      } else if ((7) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_0_7).v);
        ((arr)->data_0_7) = (dat);
      } else if ((6) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_0_6).v);
        ((arr)->data_0_6) = (dat);
      } else if ((5) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_0_5).v);
        ((arr)->data_0_5) = (dat);
      } else if ((4) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_0_4).v);
        ((arr)->data_0_4) = (dat);
      } else if ((3) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_0_3).v);
        ((arr)->data_0_3) = (dat);
      } else if ((2) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_0_2).v);
        ((arr)->data_0_2) = (dat);
      } else if ((1) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_0_1).v);
        ((arr)->data_0_1) = (dat);
      } else if ((0) == ((key_1).v)) {
        (((arr)->sum).v) -= (((arr)->data_0_0).v);
        ((arr)->data_0_0) = (dat);
      }
    }
  }
  (((arr)->sum).v) += ((dat).v);
}
struct Map_1 ZeroInit_Map_1(void) {
  struct Map_1 tmp;
  ((tmp).sum) = (Init_sol_uint256_t(0));
  ((tmp).data_0) = (Init_sol_uint256_t(0));
  ((tmp).data_1) = (Init_sol_uint256_t(0));
  ((tmp).data_2) = (Init_sol_uint256_t(0));
  ((tmp).data_3) = (Init_sol_uint256_t(0));
  ((tmp).data_4) = (Init_sol_uint256_t(0));
  ((tmp).data_5) = (Init_sol_uint256_t(0));
  ((tmp).data_6) = (Init_sol_uint256_t(0));
  ((tmp).data_7) = (Init_sol_uint256_t(0));
  ((tmp).data_8) = (Init_sol_uint256_t(0));
  ((tmp).data_9) = (Init_sol_uint256_t(0));
  ((tmp).data_10) = (Init_sol_uint256_t(0));
  ((tmp).data_11) = (Init_sol_uint256_t(0));
  return tmp;
}
sol_uint256_t Read_Map_1(struct Map_1 *arr, sol_address_t key_0) {
  {
    sol_assert((12) >= ((key_0).v),
               "Model failure, mapping key out of bounds.");
    if ((11) == ((key_0).v))
      return (arr)->data_11;
    else if ((10) == ((key_0).v))
      return (arr)->data_10;
    else if ((9) == ((key_0).v))
      return (arr)->data_9;
    else if ((8) == ((key_0).v))
      return (arr)->data_8;
    else if ((7) == ((key_0).v))
      return (arr)->data_7;
    else if ((6) == ((key_0).v))
      return (arr)->data_6;
    else if ((5) == ((key_0).v))
      return (arr)->data_5;
    else if ((4) == ((key_0).v))
      return (arr)->data_4;
    else if ((3) == ((key_0).v))
      return (arr)->data_3;
    else if ((2) == ((key_0).v))
      return (arr)->data_2;
    else if ((1) == ((key_0).v))
      return (arr)->data_1;
    else if ((0) == ((key_0).v))
      return (arr)->data_0;
  }
  return Init_sol_uint256_t(0);
}
void Write_Map_1(struct Map_1 *arr, sol_address_t key_0, sol_uint256_t dat) {
  {
    sol_assert((12) >= ((key_0).v),
               "Model failure, mapping key out of bounds.");
    if ((11) == ((key_0).v)) {
      (((arr)->sum).v) -= (((arr)->data_11).v);
      ((arr)->data_11) = (dat);
    } else if ((10) == ((key_0).v)) {
      (((arr)->sum).v) -= (((arr)->data_10).v);
      ((arr)->data_10) = (dat);
    } else if ((9) == ((key_0).v)) {
      (((arr)->sum).v) -= (((arr)->data_9).v);
      ((arr)->data_9) = (dat);
    } else if ((8) == ((key_0).v)) {
      (((arr)->sum).v) -= (((arr)->data_8).v);
      ((arr)->data_8) = (dat);
    } else if ((7) == ((key_0).v)) {
      (((arr)->sum).v) -= (((arr)->data_7).v);
      ((arr)->data_7) = (dat);
    } else if ((6) == ((key_0).v)) {
      (((arr)->sum).v) -= (((arr)->data_6).v);
      ((arr)->data_6) = (dat);
    } else if ((5) == ((key_0).v)) {
      (((arr)->sum).v) -= (((arr)->data_5).v);
      ((arr)->data_5) = (dat);
    } else if ((4) == ((key_0).v)) {
      (((arr)->sum).v) -= (((arr)->data_4).v);
      ((arr)->data_4) = (dat);
    } else if ((3) == ((key_0).v)) {
      (((arr)->sum).v) -= (((arr)->data_3).v);
      ((arr)->data_3) = (dat);
    } else if ((2) == ((key_0).v)) {
      (((arr)->sum).v) -= (((arr)->data_2).v);
      ((arr)->data_2) = (dat);
    } else if ((1) == ((key_0).v)) {
      (((arr)->sum).v) -= (((arr)->data_1).v);
      ((arr)->data_1) = (dat);
    } else if ((0) == ((key_0).v)) {
      (((arr)->sum).v) -= (((arr)->data_0).v);
      ((arr)->data_0) = (dat);
    }
  }
  (((arr)->sum).v) += ((dat).v);
}
void GVToken_Constructor(struct GVToken *self, sol_address_t sender,
                         sol_uint256_t value, sol_uint256_t blocknum,
                         sol_uint256_t timestamp, sol_bool_t paid,
                         sol_address_t origin, sol_address_t func_user___ico,
                         sol_address_t func_user___migrationMaster) {
  sol_require(((func_user___ico).v) != (g_literal_address_0), 0);
  sol_require(((func_user___migrationMaster).v) != (g_literal_address_0), 0);
  ((self->user_ico).v) = ((func_user___ico).v);
  ((self->user_migrationMaster).v) = ((func_user___migrationMaster).v);
}
void Init_ERC20Basic_For_GVToken(struct GVToken *self, sol_address_t sender,
                                 sol_uint256_t value, sol_uint256_t blocknum,
                                 sol_uint256_t timestamp, sol_bool_t paid,
                                 sol_address_t origin) {
  ((self)->user_totalSupply) = (Init_sol_uint256_t(0));
}
void Init_ERC20_For_GVToken(struct GVToken *self, sol_address_t sender,
                            sol_uint256_t value, sol_uint256_t blocknum,
                            sol_uint256_t timestamp, sol_bool_t paid,
                            sol_address_t origin) {
  Init_ERC20Basic_For_GVToken(self, sender, value, blocknum, timestamp,
                              Init_sol_bool_t(0), origin);
}
void Init_BasicToken_For_GVToken(struct GVToken *self, sol_address_t sender,
                                 sol_uint256_t value, sol_uint256_t blocknum,
                                 sol_uint256_t timestamp, sol_bool_t paid,
                                 sol_address_t origin) {
  ((self)->user_balances) = (ZeroInit_Map_1());
}
void Init_StandardToken_For_GVToken(struct GVToken *self, sol_address_t sender,
                                    sol_uint256_t value, sol_uint256_t blocknum,
                                    sol_uint256_t timestamp, sol_bool_t paid,
                                    sol_address_t origin) {
  ((self)->user_allowed) = (ZeroInit_Map_2());
  Init_ERC20_For_GVToken(self, sender, value, blocknum, timestamp,
                         Init_sol_bool_t(0), origin);
  Init_BasicToken_For_GVToken(self, sender, value, blocknum, timestamp,
                              Init_sol_bool_t(0), origin);
}
void Init_GVToken(struct GVToken *self, sol_address_t sender,
                  sol_uint256_t value, sol_uint256_t blocknum,
                  sol_uint256_t timestamp, sol_bool_t paid,
                  sol_address_t origin, sol_address_t user___ico,
                  sol_address_t user___migrationMaster) {
  ((self)->model_balance) = (Init_sol_uint256_t(0));
  ((self)->user_ico) = (Init_sol_address_t(0));
  ((self)->user_isFrozen) = (Init_sol_bool_t(1));
  ((self)->user_migrationMaster) = (Init_sol_address_t(0));
  ((self)->user_migrationAgent) = (Init_sol_address_t(0));
  ((self)->user_totalMigrated) = (Init_sol_uint256_t(0));
  Init_StandardToken_For_GVToken(self, sender, value, blocknum, timestamp,
                                 Init_sol_bool_t(0), origin);
  GVToken_Constructor(self, sender, value, blocknum, timestamp,
                      Init_sol_bool_t(0), origin, user___ico,
                      user___migrationMaster);
}
void GVToken_Method_mint(struct GVToken *self, sol_address_t sender,
                         sol_uint256_t value, sol_uint256_t blocknum,
                         sol_uint256_t timestamp, sol_bool_t paid,
                         sol_address_t origin, sol_address_t func_user_holder,
                         sol_uint256_t func_user_value) {
  sol_require(((sender).v) == ((self->user_ico).v), 0);
  sol_require(((func_user_value).v) > (0), 0);
  sol_require((((self->user_totalSupply).v) + ((func_user_value).v)) <=
                  (440000000000000000),
              0);
  Write_Map_1(
      &(self->user_balances), Init_sol_address_t((func_user_holder).v),
      Init_sol_uint256_t(((Read_Map_1(&(self->user_balances),
                                      Init_sol_address_t((func_user_holder).v)))
                              .v) +
                         ((func_user_value).v)));
  ((self->user_totalSupply).v) =
      (((self->user_totalSupply).v) + ((func_user_value).v));
  {
    g_literal_address_0;
    (func_user_holder).v;
    (func_user_value).v;
    sol_emit("Transfer(address(0), holder, value)");
  }
}
void GVToken_Method_unfreeze(struct GVToken *self, sol_address_t sender,
                             sol_uint256_t value, sol_uint256_t blocknum,
                             sol_uint256_t timestamp, sol_bool_t paid,
                             sol_address_t origin) {
  sol_require(((sender).v) == ((self->user_ico).v), 0);
  ((self->user_isFrozen).v) = (0);
}
sol_bool_t BasicToken_Method_For_GVToken_transfer(
    struct GVToken *self, sol_address_t sender, sol_uint256_t value,
    sol_uint256_t blocknum, sol_uint256_t timestamp, sol_bool_t paid,
    sol_address_t origin, sol_address_t func_user___to,
    sol_uint256_t func_user___value) {
  Write_Map_1(
      &(self->user_balances), Init_sol_address_t((sender).v),
      Init_sol_uint256_t(
          (SafeMath_Method_sub(
               Init_sol_uint256_t((Read_Map_1(&(self->user_balances),
                                              Init_sol_address_t((sender).v)))
                                      .v),
               Init_sol_uint256_t((func_user___value).v)))
              .v));
  Write_Map_1(&(self->user_balances), Init_sol_address_t((func_user___to).v),
              Init_sol_uint256_t(
                  (SafeMath_Method_add(
                       Init_sol_uint256_t(
                           (Read_Map_1(&(self->user_balances),
                                       Init_sol_address_t((func_user___to).v)))
                               .v),
                       Init_sol_uint256_t((func_user___value).v)))
                      .v));
  {
    (sender).v;
    (func_user___to).v;
    (func_user___value).v;
    sol_emit("Transfer(msg.sender, _to, _value)");
  }
  { return Init_sol_bool_t(1); }
}
sol_bool_t GVToken_Method_transfer(struct GVToken *self, sol_address_t sender,
                                   sol_uint256_t value, sol_uint256_t blocknum,
                                   sol_uint256_t timestamp, sol_bool_t paid,
                                   sol_address_t origin,
                                   sol_address_t func_user___to,
                                   sol_uint256_t func_user___value) {
  sol_require(((func_user___to).v) != (g_literal_address_0), 0);
  sol_require(!((self->user_isFrozen).v), 0);
  {
    return Init_sol_bool_t(
        (BasicToken_Method_For_GVToken_transfer(
             self, sender, value, blocknum, timestamp, Init_sol_bool_t(0),
             origin, Init_sol_address_t((func_user___to).v),
             Init_sol_uint256_t((func_user___value).v)))
            .v);
  }
}
sol_bool_t StandardToken_Method_For_GVToken_transferFrom(
    struct GVToken *self, sol_address_t sender, sol_uint256_t value,
    sol_uint256_t blocknum, sol_uint256_t timestamp, sol_bool_t paid,
    sol_address_t origin, sol_address_t func_user___from,
    sol_address_t func_user___to, sol_uint256_t func_user___value) {
  sol_uint256_t func_user___allowance =
      Init_sol_uint256_t((Read_Map_2(&(self->user_allowed),
                                     Init_sol_address_t((func_user___from).v),
                                     Init_sol_address_t((sender).v)))
                             .v);
  Write_Map_1(&(self->user_balances), Init_sol_address_t((func_user___to).v),
              Init_sol_uint256_t(
                  (SafeMath_Method_add(
                       Init_sol_uint256_t(
                           (Read_Map_1(&(self->user_balances),
                                       Init_sol_address_t((func_user___to).v)))
                               .v),
                       Init_sol_uint256_t((func_user___value).v)))
                      .v));
  Write_Map_1(
      &(self->user_balances), Init_sol_address_t((func_user___from).v),
      Init_sol_uint256_t(
          (SafeMath_Method_sub(
               Init_sol_uint256_t(
                   (Read_Map_1(&(self->user_balances),
                               Init_sol_address_t((func_user___from).v)))
                       .v),
               Init_sol_uint256_t((func_user___value).v)))
              .v));
  Write_Map_2(
      &(self->user_allowed), Init_sol_address_t((func_user___from).v),
      Init_sol_address_t((sender).v),
      Init_sol_uint256_t(
          (SafeMath_Method_sub(Init_sol_uint256_t((func_user___allowance).v),
                               Init_sol_uint256_t((func_user___value).v)))
              .v));
  {
    (func_user___from).v;
    (func_user___to).v;
    (func_user___value).v;
    sol_emit("Transfer(_from, _to, _value)");
  }
  { return Init_sol_bool_t(1); }
}
sol_bool_t GVToken_Method_transferFrom(
    struct GVToken *self, sol_address_t sender, sol_uint256_t value,
    sol_uint256_t blocknum, sol_uint256_t timestamp, sol_bool_t paid,
    sol_address_t origin, sol_address_t func_user___from,
    sol_address_t func_user___to, sol_uint256_t func_user___value) {
  sol_require(!((self->user_isFrozen).v), 0);
  {
    return Init_sol_bool_t(
        (StandardToken_Method_For_GVToken_transferFrom(
             self, sender, value, blocknum, timestamp, Init_sol_bool_t(0),
             origin, Init_sol_address_t((func_user___from).v),
             Init_sol_address_t((func_user___to).v),
             Init_sol_uint256_t((func_user___value).v)))
            .v);
  }
}
sol_bool_t StandardToken_Method_For_GVToken_approve(
    struct GVToken *self, sol_address_t sender, sol_uint256_t value,
    sol_uint256_t blocknum, sol_uint256_t timestamp, sol_bool_t paid,
    sol_address_t origin, sol_address_t func_user___spender,
    sol_uint256_t func_user___value) {
  sol_require(
      (((func_user___value).v) == (0)) ||
          (((Read_Map_2(&(self->user_allowed), Init_sol_address_t((sender).v),
                        Init_sol_address_t((func_user___spender).v)))
                .v) == (0)),
      0);
  Write_Map_2(&(self->user_allowed), Init_sol_address_t((sender).v),
              Init_sol_address_t((func_user___spender).v),
              Init_sol_uint256_t((func_user___value).v));
  {
    (sender).v;
    (func_user___spender).v;
    (func_user___value).v;
    sol_emit("Approval(msg.sender, _spender, _value)");
  }
  { return Init_sol_bool_t(1); }
}
sol_bool_t GVToken_Method_approve(struct GVToken *self, sol_address_t sender,
                                  sol_uint256_t value, sol_uint256_t blocknum,
                                  sol_uint256_t timestamp, sol_bool_t paid,
                                  sol_address_t origin,
                                  sol_address_t func_user___spender,
                                  sol_uint256_t func_user___value) {
  sol_require(!((self->user_isFrozen).v), 0);
  {
    return Init_sol_bool_t(
        (StandardToken_Method_For_GVToken_approve(
             self, sender, value, blocknum, timestamp, Init_sol_bool_t(0),
             origin, Init_sol_address_t((func_user___spender).v),
             Init_sol_uint256_t((func_user___value).v)))
            .v);
  }
}
void GVToken_Method_migrate(struct GVToken *self, sol_address_t sender,
                            sol_uint256_t value, sol_uint256_t blocknum,
                            sol_uint256_t timestamp, sol_bool_t paid,
                            sol_address_t origin,
                            sol_uint256_t func_user_value) {
  sol_require(((self->user_migrationAgent).v) != (g_literal_address_0), 0);
  sol_require(((func_user_value).v) > (0), 0);
  sol_require(
      ((func_user_value).v) <=
          ((Read_Map_1(&(self->user_balances), Init_sol_address_t((sender).v)))
               .v),
      0);
  Write_Map_1(&(self->user_balances), Init_sol_address_t((sender).v),
              Init_sol_uint256_t(((Read_Map_1(&(self->user_balances),
                                              Init_sol_address_t((sender).v)))
                                      .v) -
                                 ((func_user_value).v)));
  ((self->user_totalSupply).v) =
      (((self->user_totalSupply).v) - ((func_user_value).v));
  ((self->user_totalMigrated).v) =
      (((self->user_totalMigrated).v) + ((func_user_value).v));
  sol_address_t func_user_agent =
      Init_sol_address_t((self->user_migrationAgent).v);
  {
    (sender).v;
    (func_user_agent).v;
    (func_user_value).v;
    sol_emit("Migrate(msg.sender, agent, value)");
  }
}
void GVToken_Method_setMigrationAgent(struct GVToken *self,
                                      sol_address_t sender, sol_uint256_t value,
                                      sol_uint256_t blocknum,
                                      sol_uint256_t timestamp, sol_bool_t paid,
                                      sol_address_t origin,
                                      sol_address_t func_user___agent) {
  sol_require(((self->user_migrationAgent).v) == (g_literal_address_0), 0);
  sol_require(((sender).v) == ((self->user_migrationMaster).v), 0);
  ((self->user_migrationAgent).v) = ((func_user___agent).v);
}
void GVToken_Method_setMigrationMaster(
    struct GVToken *self, sol_address_t sender, sol_uint256_t value,
    sol_uint256_t blocknum, sol_uint256_t timestamp, sol_bool_t paid,
    sol_address_t origin, sol_address_t func_user___master) {
  sol_require(((sender).v) == ((self->user_migrationMaster).v), 0);
  sol_require(((func_user___master).v) != (g_literal_address_0), 0);
  ((self->user_migrationMaster).v) = ((func_user___master).v);
}
sol_uint256_t StandardToken_Method_For_GVToken_allowance(
    struct GVToken *self, sol_address_t sender, sol_uint256_t value,
    sol_uint256_t blocknum, sol_uint256_t timestamp, sol_bool_t paid,
    sol_address_t origin, sol_address_t func_user___owner,
    sol_address_t func_user___spender) {
  sol_uint256_t func_user_remaining = Init_sol_uint256_t(0);
  {
    return Init_sol_uint256_t(
        (Read_Map_2(&(self->user_allowed),
                    Init_sol_address_t((func_user___owner).v),
                    Init_sol_address_t((func_user___spender).v)))
            .v);
  }
  return func_user_remaining;
}
sol_uint256_t BasicToken_Method_For_GVToken_balanceOf(
    struct GVToken *self, sol_address_t sender, sol_uint256_t value,
    sol_uint256_t blocknum, sol_uint256_t timestamp, sol_bool_t paid,
    sol_address_t origin, sol_address_t func_user___owner) {
  sol_uint256_t func_user_balance = Init_sol_uint256_t(0);
  {
    return Init_sol_uint256_t(
        (Read_Map_1(&(self->user_balances),
                    Init_sol_address_t((func_user___owner).v)))
            .v);
  }
  return func_user_balance;
}
void GVOptionProgram_Constructor(
    struct GVOptionProgram *self, sol_address_t sender, sol_uint256_t value,
    sol_uint256_t blocknum, sol_uint256_t timestamp, sol_bool_t paid,
    sol_address_t origin, sol_address_t func_user___ico,
    sol_address_t func_user___gvAgent, sol_address_t func_user___team) {
  Init_GVOptionToken(
      &(self->user_gvOptionToken30), (self)->model_address,
      Init_sol_uint256_t(0), blocknum, timestamp, Init_sol_bool_t(1), origin,
      Init_sol_address_t(((self)->model_address).v), Init_sol_uint256_t(3),
      Init_sol_uint256_t(6), Init_sol_uint256_t(26000000000000000));
  Init_GVOptionToken(
      &(self->user_gvOptionToken20), (self)->model_address,
      Init_sol_uint256_t(0), blocknum, timestamp, Init_sol_bool_t(1), origin,
      Init_sol_address_t(((self)->model_address).v), Init_sol_uint256_t(4),
      Init_sol_uint256_t(7), Init_sol_uint256_t(36000000000000000));
  Init_GVOptionToken(
      &(self->user_gvOptionToken10), (self)->model_address,
      Init_sol_uint256_t(0), blocknum, timestamp, Init_sol_bool_t(1), origin,
      Init_sol_address_t(((self)->model_address).v), Init_sol_uint256_t(5),
      Init_sol_uint256_t(8), Init_sol_uint256_t(55000000000000000));
  ((self->user_gvAgent).v) = ((func_user___gvAgent).v);
  ((self->user_team).v) = ((func_user___team).v);
  ((self->user_ico).v) = ((func_user___ico).v);
}
void Init_GVOptionProgram(struct GVOptionProgram *self, sol_address_t sender,
                          sol_uint256_t value, sol_uint256_t blocknum,
                          sol_uint256_t timestamp, sol_bool_t paid,
                          sol_address_t origin, sol_address_t user___ico,
                          sol_address_t user___gvAgent,
                          sol_address_t user___team) {
  ((self)->model_balance) = (Init_sol_uint256_t(0));
  ((self)->user_gvAgent) = (Init_sol_address_t(0));
  ((self)->user_team) = (Init_sol_address_t(0));
  ((self)->user_ico) = (Init_sol_address_t(0));
  GVOptionProgram_Constructor(self, sender, value, blocknum, timestamp,
                              Init_sol_bool_t(0), origin, user___ico,
                              user___gvAgent, user___team);
}
sol_uint256_t GVOptionProgram_Method_getBalance(
    struct GVOptionProgram *self, sol_address_t sender, sol_uint256_t value,
    sol_uint256_t blocknum, sol_uint256_t timestamp, sol_bool_t paid,
    sol_address_t origin, sol_uint256_t *func_user_1,
    sol_uint256_t *func_user_2) {
  (*(func_user_1)) = (Init_sol_uint256_t(0));
  (*(func_user_2)) = (Init_sol_uint256_t(0));
  {
    (*(func_user_2)) = (Init_sol_uint256_t(
        (GVOptionToken_Method_remainingTokensCount(
             &(self->user_gvOptionToken10), (self)->model_address,
             Init_sol_uint256_t(0), blocknum, timestamp, Init_sol_bool_t(1),
             origin))
            .v));
    (*(func_user_1)) = (Init_sol_uint256_t(
        (GVOptionToken_Method_remainingTokensCount(
             &(self->user_gvOptionToken20), (self)->model_address,
             Init_sol_uint256_t(0), blocknum, timestamp, Init_sol_bool_t(1),
             origin))
            .v));
    return Init_sol_uint256_t(
        (GVOptionToken_Method_remainingTokensCount(
             &(self->user_gvOptionToken30), (self)->model_address,
             Init_sol_uint256_t(0), blocknum, timestamp, Init_sol_bool_t(1),
             origin))
            .v);
  }
}
sol_uint256_t GVOptionProgram_Method_1_executeOptions(
    struct GVOptionProgram *self, sol_address_t sender, sol_uint256_t value,
    sol_uint256_t blocknum, sol_uint256_t timestamp, sol_bool_t paid,
    sol_address_t origin, sol_uint256_t *func_user_remainingCents,
    sol_address_t func_user_buyer, sol_uint256_t func_user_usdCents,
    sol_uint256_t func_user_txHash) {
  sol_uint256_t func_user_executedTokens = Init_sol_uint256_t(0);
  (*(func_user_remainingCents)) = (Init_sol_uint256_t(0));
  sol_require(((func_user_usdCents).v) > (0), 0);
  {
    sol_uint256_t blockvar_0;
    sol_uint256_t blockvar_1;
    ((blockvar_0).v) =
        ((GVOptionProgram_Method_executeIfAvailable(
              self, sender, value, blocknum, timestamp, Init_sol_bool_t(0),
              origin, &(blockvar_1), Init_sol_address_t((func_user_buyer).v),
              Init_sol_uint256_t((func_user_usdCents).v),
              Init_sol_uint256_t((func_user_txHash).v),
              self->user_gvOptionToken30, Init_sol_uint8_t(0),
              Init_sol_uint256_t(136842100)))
             .v);
    ((func_user_executedTokens).v) = ((blockvar_0).v);
    ((*(func_user_remainingCents)).v) = ((blockvar_1).v);
  }
  if (((*(func_user_remainingCents)).v) == (0)) {
    {
      (*(func_user_remainingCents)) = (Init_sol_uint256_t(0));
      return Init_sol_uint256_t((func_user_executedTokens).v);
    }
  }
  sol_uint256_t func_user_executed20;
  {
    sol_uint256_t blockvar_0;
    sol_uint256_t blockvar_1;
    ((blockvar_0).v) =
        ((GVOptionProgram_Method_executeIfAvailable(
              self, sender, value, blocknum, timestamp, Init_sol_bool_t(0),
              origin, &(blockvar_1), Init_sol_address_t((func_user_buyer).v),
              Init_sol_uint256_t((*(func_user_remainingCents)).v),
              Init_sol_uint256_t((func_user_txHash).v),
              self->user_gvOptionToken20, Init_sol_uint8_t(1),
              Init_sol_uint256_t(126315700)))
             .v);
    ((func_user_executed20).v) = ((blockvar_0).v);
    ((*(func_user_remainingCents)).v) = ((blockvar_1).v);
  }
  if (((*(func_user_remainingCents)).v) == (0)) {
    {
      (*(func_user_remainingCents)) = (Init_sol_uint256_t(0));
      return Init_sol_uint256_t(((func_user_executedTokens).v) +
                                ((func_user_executed20).v));
    }
  }
  sol_uint256_t func_user_executed10;
  {
    sol_uint256_t blockvar_0;
    sol_uint256_t blockvar_1;
    ((blockvar_0).v) =
        ((GVOptionProgram_Method_executeIfAvailable(
              self, sender, value, blocknum, timestamp, Init_sol_bool_t(0),
              origin, &(blockvar_1), Init_sol_address_t((func_user_buyer).v),
              Init_sol_uint256_t((*(func_user_remainingCents)).v),
              Init_sol_uint256_t((func_user_txHash).v),
              self->user_gvOptionToken10, Init_sol_uint8_t(2),
              Init_sol_uint256_t(115789400)))
             .v);
    ((func_user_executed10).v) = ((blockvar_0).v);
    ((*(func_user_remainingCents)).v) = ((blockvar_1).v);
  }
  {
    (*(func_user_remainingCents)) =
        (Init_sol_uint256_t((*(func_user_remainingCents)).v));
    return Init_sol_uint256_t(
        (((func_user_executedTokens).v) + ((func_user_executed20).v)) +
        ((func_user_executed10).v));
  }
  return func_user_executedTokens;
}
sol_uint256_t GVOptionProgram_Method_executeOptions(
    struct GVOptionProgram *self, sol_address_t sender, sol_uint256_t value,
    sol_uint256_t blocknum, sol_uint256_t timestamp, sol_bool_t paid,
    sol_address_t origin, sol_uint256_t *func_model_remainingCents,
    sol_address_t func_model_buyer, sol_uint256_t func_model_usdCents,
    sol_uint256_t func_model_txHash) {
  sol_uint256_t func_model_rv;
  sol_require(((sender).v) == ((self->user_ico).v), 0);
  (func_model_rv) = (GVOptionProgram_Method_1_executeOptions(
      self, sender, value, blocknum, timestamp, Init_sol_bool_t(0), origin,
      func_model_remainingCents, func_model_buyer, func_model_usdCents,
      func_model_txHash));
  return func_model_rv;
}
void GVOptionProgram_Method_1_buyOptions(
    struct GVOptionProgram *self, sol_address_t sender, sol_uint256_t value,
    sol_uint256_t blocknum, sol_uint256_t timestamp, sol_bool_t paid,
    sol_address_t origin, sol_address_t func_user_buyer,
    sol_uint256_t func_user_usdCents, sol_uint256_t func_user_txHash) {
  sol_require(((func_user_usdCents).v) > (0), 0);
  sol_uint256_t func_user_remainUsdCents = Init_sol_uint256_t(
      (GVOptionProgram_Method_buyIfAvailable(
           self, sender, value, blocknum, timestamp, Init_sol_bool_t(0), origin,
           Init_sol_address_t((func_user_buyer).v),
           Init_sol_uint256_t((func_user_usdCents).v),
           Init_sol_uint256_t((func_user_txHash).v), self->user_gvOptionToken30,
           Init_sol_uint8_t(0), Init_sol_uint256_t(2600000000)))
          .v);
  if (((func_user_remainUsdCents).v) == (0)) {
    return;
  }
  ((func_user_remainUsdCents).v) =
      ((GVOptionProgram_Method_buyIfAvailable(
            self, sender, value, blocknum, timestamp, Init_sol_bool_t(0),
            origin, Init_sol_address_t((func_user_buyer).v),
            Init_sol_uint256_t((func_user_remainUsdCents).v),
            Init_sol_uint256_t((func_user_txHash).v),
            self->user_gvOptionToken20, Init_sol_uint8_t(1),
            Init_sol_uint256_t(2400000000)))
           .v);
  if (((func_user_remainUsdCents).v) == (0)) {
    return;
  }
  ((func_user_remainUsdCents).v) =
      ((GVOptionProgram_Method_buyIfAvailable(
            self, sender, value, blocknum, timestamp, Init_sol_bool_t(0),
            origin, Init_sol_address_t((func_user_buyer).v),
            Init_sol_uint256_t((func_user_remainUsdCents).v),
            Init_sol_uint256_t((func_user_txHash).v),
            self->user_gvOptionToken10, Init_sol_uint8_t(2),
            Init_sol_uint256_t(2200000000)))
           .v);
}
void GVOptionProgram_Method_buyOptions(
    struct GVOptionProgram *self, sol_address_t sender, sol_uint256_t value,
    sol_uint256_t blocknum, sol_uint256_t timestamp, sol_bool_t paid,
    sol_address_t origin, sol_address_t func_model_buyer,
    sol_uint256_t func_model_usdCents, sol_uint256_t func_model_txHash) {
  sol_require(((sender).v) == ((self->user_ico).v), 0);
  GVOptionProgram_Method_1_buyOptions(
      self, sender, value, blocknum, timestamp, Init_sol_bool_t(0), origin,
      func_model_buyer, func_model_usdCents, func_model_txHash);
}
sol_uint256_t GVOptionProgram_Method_executeIfAvailable(
    struct GVOptionProgram *self, sol_address_t sender, sol_uint256_t value,
    sol_uint256_t blocknum, sol_uint256_t timestamp, sol_bool_t paid,
    sol_address_t origin, sol_uint256_t *func_user_remainingCents,
    sol_address_t func_user_buyer, sol_uint256_t func_user_usdCents,
    sol_uint256_t func_user_txHash, struct GVOptionToken func_user_optionToken,
    sol_uint8_t func_user_optionType, sol_uint256_t func_user_optionPerCent) {
  sol_uint256_t func_user_executedTokens = Init_sol_uint256_t(0);
  (*(func_user_remainingCents)) = (Init_sol_uint256_t(0));
  sol_uint256_t func_user_optionsAmount = Init_sol_uint256_t(
      ((func_user_usdCents).v) * ((func_user_optionPerCent).v));
  ((func_user_executedTokens).v) =
      ((GVOptionToken_Method_executeOption(
            &(func_user_optionToken), (self)->model_address,
            Init_sol_uint256_t(0), blocknum, timestamp, Init_sol_bool_t(1),
            origin, Init_sol_address_t((func_user_buyer).v),
            Init_sol_uint256_t((func_user_optionsAmount).v)))
           .v);
  ((*(func_user_remainingCents)).v) =
      (((func_user_usdCents).v) -
       (((func_user_executedTokens).v) / ((func_user_optionPerCent).v)));
  if (((func_user_executedTokens).v) > (0)) {
    {
      (func_user_buyer).v;
      (func_user_executedTokens).v;
      (func_user_txHash).v;
      (func_user_optionType).v;
      sol_emit("ExecuteOptions(buyer, executedTokens, txHash, optionType)");
    }
  }
  {
    (*(func_user_remainingCents)) =
        (Init_sol_uint256_t((*(func_user_remainingCents)).v));
    return Init_sol_uint256_t((func_user_executedTokens).v);
  }
  return func_user_executedTokens;
}
sol_uint256_t GVOptionProgram_Method_buyIfAvailable(
    struct GVOptionProgram *self, sol_address_t sender, sol_uint256_t value,
    sol_uint256_t blocknum, sol_uint256_t timestamp, sol_bool_t paid,
    sol_address_t origin, sol_address_t func_user_buyer,
    sol_uint256_t func_user_usdCents, sol_uint256_t func_user_txHash,
    struct GVOptionToken func_user_optionToken,
    sol_uint8_t func_user_optionType, sol_uint256_t func_user_optionsPerCent) {
  sol_uint256_t func_user_availableTokens =
      Init_sol_uint256_t((GVOptionToken_Method_remainingTokensCount(
                              &(func_user_optionToken), (self)->model_address,
                              Init_sol_uint256_t(0), blocknum, timestamp,
                              Init_sol_bool_t(1), origin))
                             .v);
  if (((func_user_availableTokens).v) > (0)) {
    sol_uint256_t func_user_tokens = Init_sol_uint256_t(
        ((func_user_usdCents).v) * ((func_user_optionsPerCent).v));
    if (((func_user_availableTokens).v) >= ((func_user_tokens).v)) {
      GVOptionToken_Method_buyOptions(
          &(func_user_optionToken), (self)->model_address,
          Init_sol_uint256_t(0), blocknum, timestamp, Init_sol_bool_t(1),
          origin, Init_sol_address_t((func_user_buyer).v),
          Init_sol_uint256_t((func_user_tokens).v));
      {
        (func_user_buyer).v;
        (func_user_tokens).v;
        (func_user_txHash).v;
        (func_user_optionType).v;
        sol_emit("BuyOptions(buyer, tokens, txHash, optionType)");
      }
      { return Init_sol_uint256_t(0); }
    } else {
      GVOptionToken_Method_buyOptions(
          &(func_user_optionToken), (self)->model_address,
          Init_sol_uint256_t(0), blocknum, timestamp, Init_sol_bool_t(1),
          origin, Init_sol_address_t((func_user_buyer).v),
          Init_sol_uint256_t((func_user_availableTokens).v));
      {
        (func_user_buyer).v;
        (func_user_availableTokens).v;
        (func_user_txHash).v;
        (func_user_optionType).v;
        sol_emit("BuyOptions(buyer, availableTokens, txHash, optionType)");
      }
      {
        return Init_sol_uint256_t(
            ((func_user_usdCents).v) -
            (((func_user_availableTokens).v) / ((func_user_optionsPerCent).v)));
      }
    }
  }
  { return Init_sol_uint256_t((func_user_usdCents).v); }
}
void GVOptionToken_Constructor(struct GVOptionToken *self, sol_address_t sender,
                               sol_uint256_t value, sol_uint256_t blocknum,
                               sol_uint256_t timestamp, sol_bool_t paid,
                               sol_address_t origin,
                               sol_address_t func_user___optionProgram,
                               sol_uint256_t func_user___name,
                               sol_uint256_t func_user___symbol,
                               sol_uint256_t func_user___TOKEN__LIMIT) {
  sol_require(((func_user___optionProgram).v) != (g_literal_address_0), 0);
  ((self->user_optionProgram).v) = ((func_user___optionProgram).v);
  ((self->user_name).v) = ((func_user___name).v);
  ((self->user_symbol).v) = ((func_user___symbol).v);
  ((self->user_TOKEN__LIMIT).v) = ((func_user___TOKEN__LIMIT).v);
}
void Init_ERC20Basic_For_GVOptionToken(struct GVOptionToken *self,
                                       sol_address_t sender,
                                       sol_uint256_t value,
                                       sol_uint256_t blocknum,
                                       sol_uint256_t timestamp, sol_bool_t paid,
                                       sol_address_t origin) {
  ((self)->user_totalSupply) = (Init_sol_uint256_t(0));
}
void Init_ERC20_For_GVOptionToken(struct GVOptionToken *self,
                                  sol_address_t sender, sol_uint256_t value,
                                  sol_uint256_t blocknum,
                                  sol_uint256_t timestamp, sol_bool_t paid,
                                  sol_address_t origin) {
  Init_ERC20Basic_For_GVOptionToken(self, sender, value, blocknum, timestamp,
                                    Init_sol_bool_t(0), origin);
}
void Init_BasicToken_For_GVOptionToken(struct GVOptionToken *self,
                                       sol_address_t sender,
                                       sol_uint256_t value,
                                       sol_uint256_t blocknum,
                                       sol_uint256_t timestamp, sol_bool_t paid,
                                       sol_address_t origin) {
  ((self)->user_balances) = (ZeroInit_Map_1());
}
void Init_StandardToken_For_GVOptionToken(
    struct GVOptionToken *self, sol_address_t sender, sol_uint256_t value,
    sol_uint256_t blocknum, sol_uint256_t timestamp, sol_bool_t paid,
    sol_address_t origin) {
  ((self)->user_allowed) = (ZeroInit_Map_2());
  Init_ERC20_For_GVOptionToken(self, sender, value, blocknum, timestamp,
                               Init_sol_bool_t(0), origin);
  Init_BasicToken_For_GVOptionToken(self, sender, value, blocknum, timestamp,
                                    Init_sol_bool_t(0), origin);
}
void Init_GVOptionToken(struct GVOptionToken *self, sol_address_t sender,
                        sol_uint256_t value, sol_uint256_t blocknum,
                        sol_uint256_t timestamp, sol_bool_t paid,
                        sol_address_t origin,
                        sol_address_t user___optionProgram,
                        sol_uint256_t user___name, sol_uint256_t user___symbol,
                        sol_uint256_t user___TOKEN__LIMIT) {
  ((self)->model_balance) = (Init_sol_uint256_t(0));
  ((self)->user_optionProgram) = (Init_sol_address_t(0));
  ((self)->user_name) = (Init_sol_uint256_t(0));
  ((self)->user_symbol) = (Init_sol_uint256_t(0));
  ((self)->user_TOKEN__LIMIT) = (Init_sol_uint256_t(0));
  Init_StandardToken_For_GVOptionToken(self, sender, value, blocknum, timestamp,
                                       Init_sol_bool_t(0), origin);
  GVOptionToken_Constructor(self, sender, value, blocknum, timestamp,
                            Init_sol_bool_t(0), origin, user___optionProgram,
                            user___name, user___symbol, user___TOKEN__LIMIT);
}
void GVOptionToken_Method_1_buyOptions(
    struct GVOptionToken *self, sol_address_t sender, sol_uint256_t value,
    sol_uint256_t blocknum, sol_uint256_t timestamp, sol_bool_t paid,
    sol_address_t origin, sol_address_t func_user_buyer,
    sol_uint256_t func_user_value) {
  sol_require(((func_user_value).v) > (0), 0);
  sol_require((((self->user_totalSupply).v) + ((func_user_value).v)) <=
                  ((self->user_TOKEN__LIMIT).v),
              0);
  Write_Map_1(
      &(self->user_balances), Init_sol_address_t((func_user_buyer).v),
      Init_sol_uint256_t(((Read_Map_1(&(self->user_balances),
                                      Init_sol_address_t((func_user_buyer).v)))
                              .v) +
                         ((func_user_value).v)));
  ((self->user_totalSupply).v) =
      (((self->user_totalSupply).v) + ((func_user_value).v));
  {
    g_literal_address_0;
    (func_user_buyer).v;
    (func_user_value).v;
    sol_emit("Transfer(address(0), buyer, value)");
  }
}
void GVOptionToken_Method_buyOptions(struct GVOptionToken *self,
                                     sol_address_t sender, sol_uint256_t value,
                                     sol_uint256_t blocknum,
                                     sol_uint256_t timestamp, sol_bool_t paid,
                                     sol_address_t origin,
                                     sol_address_t func_model_buyer,
                                     sol_uint256_t func_model_value) {
  sol_require(((sender).v) == ((self->user_optionProgram).v), 0);
  GVOptionToken_Method_1_buyOptions(self, sender, value, blocknum, timestamp,
                                    Init_sol_bool_t(0), origin,
                                    func_model_buyer, func_model_value);
}
sol_uint256_t GVOptionToken_Method_remainingTokensCount(
    struct GVOptionToken *self, sol_address_t sender, sol_uint256_t value,
    sol_uint256_t blocknum, sol_uint256_t timestamp, sol_bool_t paid,
    sol_address_t origin) {
  {
    return Init_sol_uint256_t(((self->user_TOKEN__LIMIT).v) -
                              ((self->user_totalSupply).v));
  }
}
sol_uint256_t GVOptionToken_Method_1_executeOption(
    struct GVOptionToken *self, sol_address_t sender, sol_uint256_t value,
    sol_uint256_t blocknum, sol_uint256_t timestamp, sol_bool_t paid,
    sol_address_t origin, sol_address_t func_user_addr,
    sol_uint256_t func_user_optionsCount) {
  if (((Read_Map_1(&(self->user_balances),
                   Init_sol_address_t((func_user_addr).v)))
           .v) < ((func_user_optionsCount).v)) {
    ((func_user_optionsCount).v) =
        ((Read_Map_1(&(self->user_balances),
                     Init_sol_address_t((func_user_addr).v)))
             .v);
  }
  if (((func_user_optionsCount).v) == (0)) {
    {
      return Init_sol_uint256_t(0);
    }
  }
  Write_Map_1(
      &(self->user_balances), Init_sol_address_t((func_user_addr).v),
      Init_sol_uint256_t(((Read_Map_1(&(self->user_balances),
                                      Init_sol_address_t((func_user_addr).v)))
                              .v) -
                         ((func_user_optionsCount).v)));
  ((self->user_totalSupply).v) =
      (((self->user_totalSupply).v) - ((func_user_optionsCount).v));
  { return Init_sol_uint256_t((func_user_optionsCount).v); }
}
sol_uint256_t GVOptionToken_Method_executeOption(
    struct GVOptionToken *self, sol_address_t sender, sol_uint256_t value,
    sol_uint256_t blocknum, sol_uint256_t timestamp, sol_bool_t paid,
    sol_address_t origin, sol_address_t func_model_addr,
    sol_uint256_t func_model_optionsCount) {
  sol_uint256_t func_model_rv;
  sol_require(((sender).v) == ((self->user_optionProgram).v), 0);
  (func_model_rv) = (GVOptionToken_Method_1_executeOption(
      self, sender, value, blocknum, timestamp, Init_sol_bool_t(0), origin,
      func_model_addr, func_model_optionsCount));
  return func_model_rv;
}
sol_bool_t StandardToken_Method_For_GVOptionToken_transferFrom(
    struct GVOptionToken *self, sol_address_t sender, sol_uint256_t value,
    sol_uint256_t blocknum, sol_uint256_t timestamp, sol_bool_t paid,
    sol_address_t origin, sol_address_t func_user___from,
    sol_address_t func_user___to, sol_uint256_t func_user___value) {
  called_b = 1;
  tmp_sender = sender;
  sol_uint256_t func_user___allowance =
      Init_sol_uint256_t((Read_Map_2(&(self->user_allowed),
                                     Init_sol_address_t((func_user___from).v),
                                     Init_sol_address_t((sender).v)))
                             .v);
  Write_Map_1(&(self->user_balances), Init_sol_address_t((func_user___to).v),
              Init_sol_uint256_t(
                  (SafeMath_Method_add(
                       Init_sol_uint256_t(
                           (Read_Map_1(&(self->user_balances),
                                       Init_sol_address_t((func_user___to).v)))
                               .v),
                       Init_sol_uint256_t((func_user___value).v)))
                      .v));
  Write_Map_1(
      &(self->user_balances), Init_sol_address_t((func_user___from).v),
      Init_sol_uint256_t(
          (SafeMath_Method_sub(
               Init_sol_uint256_t(
                   (Read_Map_1(&(self->user_balances),
                               Init_sol_address_t((func_user___from).v)))
                       .v),
               Init_sol_uint256_t((func_user___value).v)))
              .v));
  Write_Map_2(
      &(self->user_allowed), Init_sol_address_t((func_user___from).v),
      Init_sol_address_t((sender).v),
      Init_sol_uint256_t(
          (SafeMath_Method_sub(Init_sol_uint256_t((func_user___allowance).v),
                               Init_sol_uint256_t((func_user___value).v)))
              .v));
  {
    (func_user___from).v;
    (func_user___to).v;
    (func_user___value).v;
    sol_emit("Transfer(_from, _to, _value)");
  }
  { return Init_sol_bool_t(1); }
}
sol_bool_t StandardToken_Method_For_GVOptionToken_approve(
    struct GVOptionToken *self, sol_address_t sender, sol_uint256_t value,
    sol_uint256_t blocknum, sol_uint256_t timestamp, sol_bool_t paid,
    sol_address_t origin, sol_address_t func_user___spender,
    sol_uint256_t func_user___value) {
  sol_require(
      (((func_user___value).v) == (0)) ||
          (((Read_Map_2(&(self->user_allowed), Init_sol_address_t((sender).v),
                        Init_sol_address_t((func_user___spender).v)))
                .v) == (0)),
      0);
  Write_Map_2(&(self->user_allowed), Init_sol_address_t((sender).v),
              Init_sol_address_t((func_user___spender).v),
              Init_sol_uint256_t((func_user___value).v));
  {
    (sender).v;
    (func_user___spender).v;
    (func_user___value).v;
    sol_emit("Approval(msg.sender, _spender, _value)");
  }
  { return Init_sol_bool_t(1); }
}
sol_uint256_t StandardToken_Method_For_GVOptionToken_allowance(
    struct GVOptionToken *self, sol_address_t sender, sol_uint256_t value,
    sol_uint256_t blocknum, sol_uint256_t timestamp, sol_bool_t paid,
    sol_address_t origin, sol_address_t func_user___owner,
    sol_address_t func_user___spender) {
  sol_uint256_t func_user_remaining = Init_sol_uint256_t(0);
  {
    return Init_sol_uint256_t(
        (Read_Map_2(&(self->user_allowed),
                    Init_sol_address_t((func_user___owner).v),
                    Init_sol_address_t((func_user___spender).v)))
            .v);
  }
  return func_user_remaining;
}
sol_bool_t BasicToken_Method_For_GVOptionToken_transfer(
    struct GVOptionToken *self, sol_address_t sender, sol_uint256_t value,
    sol_uint256_t blocknum, sol_uint256_t timestamp, sol_bool_t paid,
    sol_address_t origin, sol_address_t func_user___to,
    sol_uint256_t func_user___value) {
  called_a = 1;
  tmp_sender = sender;
  Write_Map_1(
      &(self->user_balances), Init_sol_address_t((sender).v),
      Init_sol_uint256_t(
          (SafeMath_Method_sub(
               Init_sol_uint256_t((Read_Map_1(&(self->user_balances),
                                              Init_sol_address_t((sender).v)))
                                      .v),
               Init_sol_uint256_t((func_user___value).v)))
              .v));
  Write_Map_1(&(self->user_balances), Init_sol_address_t((func_user___to).v),
              Init_sol_uint256_t(
                  (SafeMath_Method_add(
                       Init_sol_uint256_t(
                           (Read_Map_1(&(self->user_balances),
                                       Init_sol_address_t((func_user___to).v)))
                               .v),
                       Init_sol_uint256_t((func_user___value).v)))
                      .v));
  {
    (sender).v;
    (func_user___to).v;
    (func_user___value).v;
    sol_emit("Transfer(msg.sender, _to, _value)");
  }
  { return Init_sol_bool_t(1); }
}
sol_uint256_t BasicToken_Method_For_GVOptionToken_balanceOf(
    struct GVOptionToken *self, sol_address_t sender, sol_uint256_t value,
    sol_uint256_t blocknum, sol_uint256_t timestamp, sol_bool_t paid,
    sol_address_t origin, sol_address_t func_user___owner) {
  sol_uint256_t func_user_balance = Init_sol_uint256_t(0);
  {
    return Init_sol_uint256_t(
        (Read_Map_1(&(self->user_balances),
                    Init_sol_address_t((func_user___owner).v)))
            .v);
  }
  return func_user_balance;
}
void run_model(void) {
  sol_address_t last_sender;
  sol_uint256_t blocknum;
  ((blocknum).v) = (GET_ND_UINT(125, 256, "blocknum"));
  sol_uint256_t timestamp;
  ((timestamp).v) = (GET_ND_UINT(126, 256, "timestamp"));
  sol_bool_t paid;
  ((paid).v) = (1);
  struct ICO contract_1;
  struct GVToken *contract_2;
  struct GVOptionProgram *contract_3;
  struct GVOptionToken *contract_4;
  struct GVOptionToken *contract_5;
  struct GVOptionToken *contract_6;
  (g_literal_address_0) = (0);
  (((contract_1).model_address).v) = (1);
  (contract_2) = (&((contract_1).user_gvToken));
  (((contract_2)->model_address).v) = (2);
  (contract_3) = (&((contract_1).user_optionProgram));
  (((contract_3)->model_address).v) = (3);
  (contract_4) = (&((contract_3)->user_gvOptionToken30));
  (((contract_4)->model_address).v) = (4);
  (contract_5) = (&((contract_3)->user_gvOptionToken20));
  (((contract_5)->model_address).v) = (5);
  (contract_6) = (&((contract_3)->user_gvOptionToken10));
  (((contract_6)->model_address).v) = (6);
  (((contract_1).user_gvAgent).v) = (0);
  (((contract_1).user_team).v) = (0);
  (((contract_1).user_teamAllocator).v) = (0);
  (((contract_1).user_migrationMaster).v) = (0);
  (((contract_2)->user_ico).v) = (0);
  (((contract_2)->user_migrationMaster).v) = (0);
  (((contract_2)->user_migrationAgent).v) = (0);
  (((contract_3)->user_gvAgent).v) = (0);
  (((contract_3)->user_team).v) = (0);
  (((contract_3)->user_ico).v) = (0);
  (((contract_4)->user_optionProgram).v) = (0);
  (((contract_5)->user_optionProgram).v) = (0);
  (((contract_6)->user_optionProgram).v) = (0);
  smartace_log("[Initializing contract_1 and children]");
  if (GET_ND_RANGE(129, 0, 2, "take_step")) {
    ((blocknum).v) = (GET_ND_INCREASE(127, (blocknum).v, 1, "blocknum"));
    ((timestamp).v) = (GET_ND_INCREASE(128, (timestamp).v, 1, "timestamp"));
  }
  {
    sol_address_t sender;
    ((sender).v) = (GET_ND_RANGE(130, 7, 12, "sender"));
    ((last_sender).v) = ((sender).v);
    sol_uint256_t value;
    ((value).v) = (0);
    Init_ICO(
        &(contract_1), sender, value, blocknum, timestamp, paid, sender,
        Init_sol_address_t(GET_ND_RANGE(131, 0, 12, "ICO:_team")),
        Init_sol_address_t(GET_ND_RANGE(132, 0, 12, "ICO:_gvAgent")),
        Init_sol_address_t(GET_ND_RANGE(133, 0, 12, "ICO:_migrationMaster")),
        Init_sol_address_t(GET_ND_RANGE(134, 0, 12, "ICO:_teamAllocator")));
  }
  smartace_log("[Entering transaction loop]");
  while (sol_continue()) {
    sol_on_transaction();
    called_a = 0;
    called_b = 0;
    tmp_sender.v = g_literal_address_0;
    if (GET_ND_RANGE(761, 0, 2, "take_step")) {
      ((blocknum).v) = (GET_ND_INCREASE(759, (blocknum).v, 1, "blocknum"));
      ((timestamp).v) = (GET_ND_INCREASE(760, (timestamp).v, 1, "timestamp"));
    }
    uint8_t next_call;
    (next_call) = (GET_ND_RANGE(762, 0, 48, "next_call"));
    switch (next_call) {
    case 0: {
      smartace_log("[Calling initOptionProgram() on contract_1]");
      sol_address_t sender;
      ((sender).v) = (GET_ND_RANGE(0, 7, 12, "sender"));
      ((last_sender).v) = ((sender).v);
      sol_uint256_t value;
      ((value).v) = (0);
      ICO_Method_initOptionProgram(&(contract_1), sender, value, blocknum,
                                   timestamp, paid, sender);
      smartace_log("[Call successful]");
      break;
    }
    case 1: {
      smartace_log("[Calling startOptionsSelling() on contract_1]");
      sol_address_t sender;
      ((sender).v) = (GET_ND_RANGE(1, 7, 12, "sender"));
      ((last_sender).v) = ((sender).v);
      sol_uint256_t value;
      ((value).v) = (0);
      ICO_Method_startOptionsSelling(&(contract_1), sender, value, blocknum,
                                     timestamp, paid, sender);
      smartace_log("[Call successful]");
      break;
    }
    case 2: {
      smartace_log("[Calling startIcoForOptionsHolders() on contract_1]");
      sol_address_t sender;
      ((sender).v) = (GET_ND_RANGE(2, 7, 12, "sender"));
      ((last_sender).v) = ((sender).v);
      sol_uint256_t value;
      ((value).v) = (0);
      ICO_Method_startIcoForOptionsHolders(&(contract_1), sender, value,
                                           blocknum, timestamp, paid, sender);
      smartace_log("[Call successful]");
      break;
    }
    case 3: {
      smartace_log("[Calling startIco() on contract_1]");
      sol_address_t sender;
      ((sender).v) = (GET_ND_RANGE(3, 7, 12, "sender"));
      ((last_sender).v) = ((sender).v);
      sol_uint256_t value;
      ((value).v) = (0);
      ICO_Method_startIco(&(contract_1), sender, value, blocknum, timestamp,
                          paid, sender);
      smartace_log("[Call successful]");
      break;
    }
    case 4: {
      smartace_log("[Calling pauseIco() on contract_1]");
      sol_address_t sender;
      ((sender).v) = (GET_ND_RANGE(4, 7, 12, "sender"));
      ((last_sender).v) = ((sender).v);
      sol_uint256_t value;
      ((value).v) = (0);
      ICO_Method_pauseIco(&(contract_1), sender, value, blocknum, timestamp,
                          paid, sender);
      smartace_log("[Call successful]");
      break;
    }
    case 5: {
      smartace_log("[Calling resumeIco() on contract_1]");
      sol_address_t sender;
      ((sender).v) = (GET_ND_RANGE(5, 7, 12, "sender"));
      ((last_sender).v) = ((sender).v);
      sol_uint256_t value;
      ((value).v) = (0);
      ICO_Method_resumeIco(&(contract_1), sender, value, blocknum, timestamp,
                           paid, sender);
      smartace_log("[Call successful]");
      break;
    }
    case 6: {
      smartace_log("[Calling finishIco(_fund, _bounty) on contract_1]");
      sol_address_t sender;
      ((sender).v) = (GET_ND_RANGE(6, 7, 12, "sender"));
      ((last_sender).v) = ((sender).v);
      sol_uint256_t value;
      ((value).v) = (0);
      sol_address_t arg__fund =
          Init_sol_address_t(GET_ND_RANGE(7, 0, 12, "_fund"));
      sol_address_t arg__bounty =
          Init_sol_address_t(GET_ND_RANGE(8, 0, 12, "_bounty"));
      ICO_Method_finishIco(&(contract_1), sender, value, blocknum, timestamp,
                           paid, sender, arg__fund, arg__bounty);
      smartace_log("[Call successful]");
      break;
    }
    case 7: {
      smartace_log(
          "[Calling buyTokens(buyer, usdCents, txHash) on contract_1]");
      sol_address_t sender;
      ((sender).v) = (GET_ND_RANGE(9, 7, 12, "sender"));
      ((last_sender).v) = ((sender).v);
      sol_uint256_t value;
      ((value).v) = (0);
      sol_address_t arg_buyer =
          Init_sol_address_t(GET_ND_RANGE(10, 0, 12, "buyer"));
      sol_uint256_t arg_usdCents =
          Init_sol_uint256_t(GET_ND_UINT(11, 256, "usdCents"));
      sol_uint256_t arg_txHash =
          Init_sol_uint256_t(GET_ND_UINT(12, 256, "txHash"));
      ICO_Method_buyTokens(&(contract_1), sender, value, blocknum, timestamp,
                           paid, sender, arg_buyer, arg_usdCents, arg_txHash);
      smartace_log("[Call successful]");
      break;
    }
    case 8: {
      smartace_log("[Calling buyTokensByOptions(buyer, usdCents, txHash) on "
                   "contract_1]");
      sol_address_t sender;
      ((sender).v) = (GET_ND_RANGE(13, 7, 12, "sender"));
      ((last_sender).v) = ((sender).v);
      sol_uint256_t value;
      ((value).v) = (0);
      sol_address_t arg_buyer =
          Init_sol_address_t(GET_ND_RANGE(14, 0, 12, "buyer"));
      sol_uint256_t arg_usdCents =
          Init_sol_uint256_t(GET_ND_UINT(15, 256, "usdCents"));
      sol_uint256_t arg_txHash =
          Init_sol_uint256_t(GET_ND_UINT(16, 256, "txHash"));
      ICO_Method_buyTokensByOptions(&(contract_1), sender, value, blocknum,
                                    timestamp, paid, sender, arg_buyer,
                                    arg_usdCents, arg_txHash);
      smartace_log("[Call successful]");
      break;
    }
    case 9: {
      smartace_log(
          "[Calling buyOptions(buyer, usdCents, txHash) on contract_1]");
      sol_address_t sender;
      ((sender).v) = (GET_ND_RANGE(17, 7, 12, "sender"));
      ((last_sender).v) = ((sender).v);
      sol_uint256_t value;
      ((value).v) = (0);
      sol_address_t arg_buyer =
          Init_sol_address_t(GET_ND_RANGE(18, 0, 12, "buyer"));
      sol_uint256_t arg_usdCents =
          Init_sol_uint256_t(GET_ND_UINT(19, 256, "usdCents"));
      sol_uint256_t arg_txHash =
          Init_sol_uint256_t(GET_ND_UINT(20, 256, "txHash"));
      ICO_Method_buyOptions(&(contract_1), sender, value, blocknum, timestamp,
                            paid, sender, arg_buyer, arg_usdCents, arg_txHash);
      smartace_log("[Call successful]");
      break;
    }
    case 10: {
      smartace_log("[Calling bad(_from, _to, _value) on contract_1]");
      sol_address_t sender;
      ((sender).v) = (GET_ND_RANGE(21, 7, 12, "sender"));
      ((last_sender).v) = ((sender).v);
      sol_uint256_t value;
      ((value).v) = (0);
      sol_address_t arg__from =
          Init_sol_address_t(GET_ND_RANGE(22, 0, 12, "_from"));
      sol_address_t arg__to =
          Init_sol_address_t(GET_ND_RANGE(23, 0, 12, "_to"));
      sol_uint256_t arg__value =
          Init_sol_uint256_t(GET_ND_UINT(24, 256, "_value"));
      ICO_Method_bad(&(contract_1), sender, value, blocknum, timestamp, paid,
                     sender, arg__from, arg__to, arg__value);
      smartace_log("[Call successful]");
      break;
    }
    case 11: {
      smartace_log("[Calling mint(holder, value) on contract_2]");
      sol_address_t sender;
      ((sender).v) = (GET_ND_RANGE(25, 7, 12, "sender"));
      ((last_sender).v) = ((sender).v);
      sol_uint256_t value;
      ((value).v) = (0);
      sol_address_t arg_holder =
          Init_sol_address_t(GET_ND_RANGE(26, 0, 12, "holder"));
      sol_uint256_t arg_value =
          Init_sol_uint256_t(GET_ND_UINT(27, 256, "value"));
      GVToken_Method_mint(contract_2, sender, value, blocknum, timestamp, paid,
                          sender, arg_holder, arg_value);
      smartace_log("[Call successful]");
      break;
    }
    case 12: {
      smartace_log("[Calling unfreeze() on contract_2]");
      sol_address_t sender;
      ((sender).v) = (GET_ND_RANGE(28, 7, 12, "sender"));
      ((last_sender).v) = ((sender).v);
      sol_uint256_t value;
      ((value).v) = (0);
      GVToken_Method_unfreeze(contract_2, sender, value, blocknum, timestamp,
                              paid, sender);
      smartace_log("[Call successful]");
      break;
    }
    case 13: {
      smartace_log("[Calling transfer(_to, _value) on contract_2]");
      sol_address_t sender;
      ((sender).v) = (GET_ND_RANGE(29, 7, 12, "sender"));
      ((last_sender).v) = ((sender).v);
      sol_uint256_t value;
      ((value).v) = (0);
      sol_address_t arg__to =
          Init_sol_address_t(GET_ND_RANGE(30, 0, 12, "_to"));
      sol_uint256_t arg__value =
          Init_sol_uint256_t(GET_ND_UINT(31, 256, "_value"));
      GVToken_Method_transfer(contract_2, sender, value, blocknum, timestamp,
                              paid, sender, arg__to, arg__value);
      smartace_log("[Call successful]");
      break;
    }
    case 14: {
      smartace_log("[Calling transferFrom(_from, _to, _value) on contract_2]");
      sol_address_t sender;
      ((sender).v) = (GET_ND_RANGE(32, 7, 12, "sender"));
      ((last_sender).v) = ((sender).v);
      sol_uint256_t value;
      ((value).v) = (0);
      sol_address_t arg__from =
          Init_sol_address_t(GET_ND_RANGE(33, 0, 12, "_from"));
      sol_address_t arg__to =
          Init_sol_address_t(GET_ND_RANGE(34, 0, 12, "_to"));
      sol_uint256_t arg__value =
          Init_sol_uint256_t(GET_ND_UINT(35, 256, "_value"));
      GVToken_Method_transferFrom(contract_2, sender, value, blocknum,
                                  timestamp, paid, sender, arg__from, arg__to,
                                  arg__value);
      smartace_log("[Call successful]");
      break;
    }
    case 15: {
      smartace_log("[Calling approve(_spender, _value) on contract_2]");
      sol_address_t sender;
      ((sender).v) = (GET_ND_RANGE(36, 7, 12, "sender"));
      ((last_sender).v) = ((sender).v);
      sol_uint256_t value;
      ((value).v) = (0);
      sol_address_t arg__spender =
          Init_sol_address_t(GET_ND_RANGE(37, 0, 12, "_spender"));
      sol_uint256_t arg__value =
          Init_sol_uint256_t(GET_ND_UINT(38, 256, "_value"));
      GVToken_Method_approve(contract_2, sender, value, blocknum, timestamp,
                             paid, sender, arg__spender, arg__value);
      smartace_log("[Call successful]");
      break;
    }
    case 16: {
      smartace_log("[Calling migrate(value) on contract_2]");
      sol_address_t sender;
      ((sender).v) = (GET_ND_RANGE(39, 7, 12, "sender"));
      ((last_sender).v) = ((sender).v);
      sol_uint256_t value;
      ((value).v) = (0);
      sol_uint256_t arg_value =
          Init_sol_uint256_t(GET_ND_UINT(40, 256, "value"));
      GVToken_Method_migrate(contract_2, sender, value, blocknum, timestamp,
                             paid, sender, arg_value);
      smartace_log("[Call successful]");
      break;
    }
    case 17: {
      smartace_log("[Calling setMigrationAgent(_agent) on contract_2]");
      sol_address_t sender;
      ((sender).v) = (GET_ND_RANGE(41, 7, 12, "sender"));
      ((last_sender).v) = ((sender).v);
      sol_uint256_t value;
      ((value).v) = (0);
      sol_address_t arg__agent =
          Init_sol_address_t(GET_ND_RANGE(42, 0, 12, "_agent"));
      GVToken_Method_setMigrationAgent(contract_2, sender, value, blocknum,
                                       timestamp, paid, sender, arg__agent);
      smartace_log("[Call successful]");
      break;
    }
    case 18: {
      smartace_log("[Calling setMigrationMaster(_master) on contract_2]");
      sol_address_t sender;
      ((sender).v) = (GET_ND_RANGE(43, 7, 12, "sender"));
      ((last_sender).v) = ((sender).v);
      sol_uint256_t value;
      ((value).v) = (0);
      sol_address_t arg__master =
          Init_sol_address_t(GET_ND_RANGE(44, 0, 12, "_master"));
      GVToken_Method_setMigrationMaster(contract_2, sender, value, blocknum,
                                        timestamp, paid, sender, arg__master);
      smartace_log("[Call successful]");
      break;
    }
    case 19: {
      smartace_log("[Calling allowance(_owner, _spender) on contract_2]");
      sol_address_t sender;
      ((sender).v) = (GET_ND_RANGE(45, 7, 12, "sender"));
      ((last_sender).v) = ((sender).v);
      sol_uint256_t value;
      ((value).v) = (0);
      sol_address_t arg__owner =
          Init_sol_address_t(GET_ND_RANGE(46, 0, 12, "_owner"));
      sol_address_t arg__spender =
          Init_sol_address_t(GET_ND_RANGE(47, 0, 12, "_spender"));
      StandardToken_Method_For_GVToken_allowance(
          contract_2, sender, value, blocknum, timestamp, paid, sender,
          arg__owner, arg__spender);
      smartace_log("[Call successful]");
      break;
    }
    case 20: {
      smartace_log("[Calling balanceOf(_owner) on contract_2]");
      sol_address_t sender;
      ((sender).v) = (GET_ND_RANGE(48, 7, 12, "sender"));
      ((last_sender).v) = ((sender).v);
      sol_uint256_t value;
      ((value).v) = (0);
      sol_address_t arg__owner =
          Init_sol_address_t(GET_ND_RANGE(49, 0, 12, "_owner"));
      BasicToken_Method_For_GVToken_balanceOf(contract_2, sender, value,
                                              blocknum, timestamp, paid, sender,
                                              arg__owner);
      smartace_log("[Call successful]");
      break;
    }
    case 21: {
      smartace_log("[Calling getBalance() on contract_3]");
      sol_address_t sender;
      ((sender).v) = (GET_ND_RANGE(50, 7, 12, "sender"));
      ((last_sender).v) = ((sender).v);
      sol_uint256_t value;
      ((value).v) = (0);
      sol_uint256_t rv_1;
      sol_uint256_t rv_2;
      GVOptionProgram_Method_getBalance(contract_3, sender, value, blocknum,
                                        timestamp, paid, sender, &(rv_1),
                                        &(rv_2));
      smartace_log("[Call successful]");
      break;
    }
    case 22: {
      smartace_log(
          "[Calling executeOptions(buyer, usdCents, txHash) on contract_3]");
      sol_address_t sender;
      ((sender).v) = (GET_ND_RANGE(51, 7, 12, "sender"));
      ((last_sender).v) = ((sender).v);
      sol_uint256_t value;
      ((value).v) = (0);
      sol_uint256_t rv_1;
      sol_address_t arg_buyer =
          Init_sol_address_t(GET_ND_RANGE(52, 0, 12, "buyer"));
      sol_uint256_t arg_usdCents =
          Init_sol_uint256_t(GET_ND_UINT(53, 256, "usdCents"));
      sol_uint256_t arg_txHash =
          Init_sol_uint256_t(GET_ND_UINT(54, 256, "txHash"));
      GVOptionProgram_Method_executeOptions(
          contract_3, sender, value, blocknum, timestamp, paid, sender, &(rv_1),
          arg_buyer, arg_usdCents, arg_txHash);
      smartace_log("[Call successful]");
      break;
    }
    case 23: {
      smartace_log(
          "[Calling buyOptions(buyer, usdCents, txHash) on contract_3]");
      sol_address_t sender;
      ((sender).v) = (GET_ND_RANGE(55, 7, 12, "sender"));
      ((last_sender).v) = ((sender).v);
      sol_uint256_t value;
      ((value).v) = (0);
      sol_address_t arg_buyer =
          Init_sol_address_t(GET_ND_RANGE(56, 0, 12, "buyer"));
      sol_uint256_t arg_usdCents =
          Init_sol_uint256_t(GET_ND_UINT(57, 256, "usdCents"));
      sol_uint256_t arg_txHash =
          Init_sol_uint256_t(GET_ND_UINT(58, 256, "txHash"));
      GVOptionProgram_Method_buyOptions(contract_3, sender, value, blocknum,
                                        timestamp, paid, sender, arg_buyer,
                                        arg_usdCents, arg_txHash);
      smartace_log("[Call successful]");
      break;
    }
    case 24: {
      smartace_log("[Calling buyOptions(buyer, value) on contract_4]");
      sol_address_t sender;
      ((sender).v) = (GET_ND_RANGE(59, 7, 12, "sender"));
      ((last_sender).v) = ((sender).v);
      sol_uint256_t value;
      ((value).v) = (0);
      sol_address_t arg_buyer =
          Init_sol_address_t(GET_ND_RANGE(60, 0, 12, "buyer"));
      sol_uint256_t arg_value =
          Init_sol_uint256_t(GET_ND_UINT(61, 256, "value"));
      GVOptionToken_Method_buyOptions(contract_4, sender, value, blocknum,
                                      timestamp, paid, sender, arg_buyer,
                                      arg_value);
      smartace_log("[Call successful]");
      break;
    }
    case 25: {
      smartace_log("[Calling remainingTokensCount() on contract_4]");
      sol_address_t sender;
      ((sender).v) = (GET_ND_RANGE(62, 7, 12, "sender"));
      ((last_sender).v) = ((sender).v);
      sol_uint256_t value;
      ((value).v) = (0);
      GVOptionToken_Method_remainingTokensCount(
          contract_4, sender, value, blocknum, timestamp, paid, sender);
      smartace_log("[Call successful]");
      break;
    }
    case 26: {
      smartace_log("[Calling executeOption(addr, optionsCount) on contract_4]");
      sol_address_t sender;
      ((sender).v) = (GET_ND_RANGE(63, 7, 12, "sender"));
      ((last_sender).v) = ((sender).v);
      sol_uint256_t value;
      ((value).v) = (0);
      sol_address_t arg_addr =
          Init_sol_address_t(GET_ND_RANGE(64, 0, 12, "addr"));
      sol_uint256_t arg_optionsCount =
          Init_sol_uint256_t(GET_ND_UINT(65, 256, "optionsCount"));
      GVOptionToken_Method_executeOption(contract_4, sender, value, blocknum,
                                         timestamp, paid, sender, arg_addr,
                                         arg_optionsCount);
      smartace_log("[Call successful]");
      break;
    }
    case 27: {
      smartace_log("[Calling transferFrom(_from, _to, _value) on contract_4]");
      sol_address_t sender;
      ((sender).v) = (GET_ND_RANGE(66, 7, 12, "sender"));
      ((last_sender).v) = ((sender).v);
      sol_uint256_t value;
      ((value).v) = (0);
      sol_address_t arg__from =
          Init_sol_address_t(GET_ND_RANGE(67, 0, 12, "_from"));
      sol_address_t arg__to =
          Init_sol_address_t(GET_ND_RANGE(68, 0, 12, "_to"));
      sol_uint256_t arg__value =
          Init_sol_uint256_t(GET_ND_UINT(69, 256, "_value"));
      StandardToken_Method_For_GVOptionToken_transferFrom(
          contract_4, sender, value, blocknum, timestamp, paid, sender,
          arg__from, arg__to, arg__value);
      smartace_log("[Call successful]");
      break;
    }
    case 28: {
      smartace_log("[Calling approve(_spender, _value) on contract_4]");
      sol_address_t sender;
      ((sender).v) = (GET_ND_RANGE(70, 7, 12, "sender"));
      ((last_sender).v) = ((sender).v);
      sol_uint256_t value;
      ((value).v) = (0);
      sol_address_t arg__spender =
          Init_sol_address_t(GET_ND_RANGE(71, 0, 12, "_spender"));
      sol_uint256_t arg__value =
          Init_sol_uint256_t(GET_ND_UINT(72, 256, "_value"));
      StandardToken_Method_For_GVOptionToken_approve(
          contract_4, sender, value, blocknum, timestamp, paid, sender,
          arg__spender, arg__value);
      smartace_log("[Call successful]");
      break;
    }
    case 29: {
      smartace_log("[Calling allowance(_owner, _spender) on contract_4]");
      sol_address_t sender;
      ((sender).v) = (GET_ND_RANGE(73, 7, 12, "sender"));
      ((last_sender).v) = ((sender).v);
      sol_uint256_t value;
      ((value).v) = (0);
      sol_address_t arg__owner =
          Init_sol_address_t(GET_ND_RANGE(74, 0, 12, "_owner"));
      sol_address_t arg__spender =
          Init_sol_address_t(GET_ND_RANGE(75, 0, 12, "_spender"));
      StandardToken_Method_For_GVOptionToken_allowance(
          contract_4, sender, value, blocknum, timestamp, paid, sender,
          arg__owner, arg__spender);
      smartace_log("[Call successful]");
      break;
    }
    case 30: {
      smartace_log("[Calling transfer(_to, _value) on contract_4]");
      sol_address_t sender;
      ((sender).v) = (GET_ND_RANGE(76, 7, 12, "sender"));
      ((last_sender).v) = ((sender).v);
      sol_uint256_t value;
      ((value).v) = (0);
      sol_address_t arg__to =
          Init_sol_address_t(GET_ND_RANGE(77, 0, 12, "_to"));
      sol_uint256_t arg__value =
          Init_sol_uint256_t(GET_ND_UINT(78, 256, "_value"));
      BasicToken_Method_For_GVOptionToken_transfer(contract_4, sender, value,
                                                   blocknum, timestamp, paid,
                                                   sender, arg__to, arg__value);
      smartace_log("[Call successful]");
      break;
    }
    case 31: {
      smartace_log("[Calling balanceOf(_owner) on contract_4]");
      sol_address_t sender;
      ((sender).v) = (GET_ND_RANGE(79, 7, 12, "sender"));
      ((last_sender).v) = ((sender).v);
      sol_uint256_t value;
      ((value).v) = (0);
      sol_address_t arg__owner =
          Init_sol_address_t(GET_ND_RANGE(80, 0, 12, "_owner"));
      BasicToken_Method_For_GVOptionToken_balanceOf(contract_4, sender, value,
                                                    blocknum, timestamp, paid,
                                                    sender, arg__owner);
      smartace_log("[Call successful]");
      break;
    }
    case 32: {
      smartace_log("[Calling buyOptions(buyer, value) on contract_5]");
      sol_address_t sender;
      ((sender).v) = (GET_ND_RANGE(81, 7, 12, "sender"));
      ((last_sender).v) = ((sender).v);
      sol_uint256_t value;
      ((value).v) = (0);
      sol_address_t arg_buyer =
          Init_sol_address_t(GET_ND_RANGE(82, 0, 12, "buyer"));
      sol_uint256_t arg_value =
          Init_sol_uint256_t(GET_ND_UINT(83, 256, "value"));
      GVOptionToken_Method_buyOptions(contract_5, sender, value, blocknum,
                                      timestamp, paid, sender, arg_buyer,
                                      arg_value);
      smartace_log("[Call successful]");
      break;
    }
    case 33: {
      smartace_log("[Calling remainingTokensCount() on contract_5]");
      sol_address_t sender;
      ((sender).v) = (GET_ND_RANGE(84, 7, 12, "sender"));
      ((last_sender).v) = ((sender).v);
      sol_uint256_t value;
      ((value).v) = (0);
      GVOptionToken_Method_remainingTokensCount(
          contract_5, sender, value, blocknum, timestamp, paid, sender);
      smartace_log("[Call successful]");
      break;
    }
    case 34: {
      smartace_log("[Calling executeOption(addr, optionsCount) on contract_5]");
      sol_address_t sender;
      ((sender).v) = (GET_ND_RANGE(85, 7, 12, "sender"));
      ((last_sender).v) = ((sender).v);
      sol_uint256_t value;
      ((value).v) = (0);
      sol_address_t arg_addr =
          Init_sol_address_t(GET_ND_RANGE(86, 0, 12, "addr"));
      sol_uint256_t arg_optionsCount =
          Init_sol_uint256_t(GET_ND_UINT(87, 256, "optionsCount"));
      GVOptionToken_Method_executeOption(contract_5, sender, value, blocknum,
                                         timestamp, paid, sender, arg_addr,
                                         arg_optionsCount);
      smartace_log("[Call successful]");
      break;
    }
    case 35: {
      smartace_log("[Calling transferFrom(_from, _to, _value) on contract_5]");
      sol_address_t sender;
      ((sender).v) = (GET_ND_RANGE(88, 7, 12, "sender"));
      ((last_sender).v) = ((sender).v);
      sol_uint256_t value;
      ((value).v) = (0);
      sol_address_t arg__from =
          Init_sol_address_t(GET_ND_RANGE(89, 0, 12, "_from"));
      sol_address_t arg__to =
          Init_sol_address_t(GET_ND_RANGE(90, 0, 12, "_to"));
      sol_uint256_t arg__value =
          Init_sol_uint256_t(GET_ND_UINT(91, 256, "_value"));
      StandardToken_Method_For_GVOptionToken_transferFrom(
          contract_5, sender, value, blocknum, timestamp, paid, sender,
          arg__from, arg__to, arg__value);
      smartace_log("[Call successful]");
      break;
    }
    case 36: {
      smartace_log("[Calling approve(_spender, _value) on contract_5]");
      sol_address_t sender;
      ((sender).v) = (GET_ND_RANGE(92, 7, 12, "sender"));
      ((last_sender).v) = ((sender).v);
      sol_uint256_t value;
      ((value).v) = (0);
      sol_address_t arg__spender =
          Init_sol_address_t(GET_ND_RANGE(93, 0, 12, "_spender"));
      sol_uint256_t arg__value =
          Init_sol_uint256_t(GET_ND_UINT(94, 256, "_value"));
      StandardToken_Method_For_GVOptionToken_approve(
          contract_5, sender, value, blocknum, timestamp, paid, sender,
          arg__spender, arg__value);
      smartace_log("[Call successful]");
      break;
    }
    case 37: {
      smartace_log("[Calling allowance(_owner, _spender) on contract_5]");
      sol_address_t sender;
      ((sender).v) = (GET_ND_RANGE(95, 7, 12, "sender"));
      ((last_sender).v) = ((sender).v);
      sol_uint256_t value;
      ((value).v) = (0);
      sol_address_t arg__owner =
          Init_sol_address_t(GET_ND_RANGE(96, 0, 12, "_owner"));
      sol_address_t arg__spender =
          Init_sol_address_t(GET_ND_RANGE(97, 0, 12, "_spender"));
      StandardToken_Method_For_GVOptionToken_allowance(
          contract_5, sender, value, blocknum, timestamp, paid, sender,
          arg__owner, arg__spender);
      smartace_log("[Call successful]");
      break;
    }
    case 38: {
      smartace_log("[Calling transfer(_to, _value) on contract_5]");
      sol_address_t sender;
      ((sender).v) = (GET_ND_RANGE(98, 7, 12, "sender"));
      ((last_sender).v) = ((sender).v);
      sol_uint256_t value;
      ((value).v) = (0);
      sol_address_t arg__to =
          Init_sol_address_t(GET_ND_RANGE(99, 0, 12, "_to"));
      sol_uint256_t arg__value =
          Init_sol_uint256_t(GET_ND_UINT(100, 256, "_value"));
      BasicToken_Method_For_GVOptionToken_transfer(contract_5, sender, value,
                                                   blocknum, timestamp, paid,
                                                   sender, arg__to, arg__value);
      smartace_log("[Call successful]");
      break;
    }
    case 39: {
      smartace_log("[Calling balanceOf(_owner) on contract_5]");
      sol_address_t sender;
      ((sender).v) = (GET_ND_RANGE(101, 7, 12, "sender"));
      ((last_sender).v) = ((sender).v);
      sol_uint256_t value;
      ((value).v) = (0);
      sol_address_t arg__owner =
          Init_sol_address_t(GET_ND_RANGE(102, 0, 12, "_owner"));
      BasicToken_Method_For_GVOptionToken_balanceOf(contract_5, sender, value,
                                                    blocknum, timestamp, paid,
                                                    sender, arg__owner);
      smartace_log("[Call successful]");
      break;
    }
    case 40: {
      smartace_log("[Calling buyOptions(buyer, value) on contract_6]");
      sol_address_t sender;
      ((sender).v) = (GET_ND_RANGE(103, 7, 12, "sender"));
      ((last_sender).v) = ((sender).v);
      sol_uint256_t value;
      ((value).v) = (0);
      sol_address_t arg_buyer =
          Init_sol_address_t(GET_ND_RANGE(104, 0, 12, "buyer"));
      sol_uint256_t arg_value =
          Init_sol_uint256_t(GET_ND_UINT(105, 256, "value"));
      GVOptionToken_Method_buyOptions(contract_6, sender, value, blocknum,
                                      timestamp, paid, sender, arg_buyer,
                                      arg_value);
      smartace_log("[Call successful]");
      break;
    }
    case 41: {
      smartace_log("[Calling remainingTokensCount() on contract_6]");
      sol_address_t sender;
      ((sender).v) = (GET_ND_RANGE(106, 7, 12, "sender"));
      ((last_sender).v) = ((sender).v);
      sol_uint256_t value;
      ((value).v) = (0);
      GVOptionToken_Method_remainingTokensCount(
          contract_6, sender, value, blocknum, timestamp, paid, sender);
      smartace_log("[Call successful]");
      break;
    }
    case 42: {
      smartace_log("[Calling executeOption(addr, optionsCount) on contract_6]");
      sol_address_t sender;
      ((sender).v) = (GET_ND_RANGE(107, 7, 12, "sender"));
      ((last_sender).v) = ((sender).v);
      sol_uint256_t value;
      ((value).v) = (0);
      sol_address_t arg_addr =
          Init_sol_address_t(GET_ND_RANGE(108, 0, 12, "addr"));
      sol_uint256_t arg_optionsCount =
          Init_sol_uint256_t(GET_ND_UINT(109, 256, "optionsCount"));
      GVOptionToken_Method_executeOption(contract_6, sender, value, blocknum,
                                         timestamp, paid, sender, arg_addr,
                                         arg_optionsCount);
      smartace_log("[Call successful]");
      break;
    }
    case 43: {
      smartace_log("[Calling transferFrom(_from, _to, _value) on contract_6]");
      sol_address_t sender;
      ((sender).v) = (GET_ND_RANGE(110, 7, 12, "sender"));
      ((last_sender).v) = ((sender).v);
      sol_uint256_t value;
      ((value).v) = (0);
      sol_address_t arg__from =
          Init_sol_address_t(GET_ND_RANGE(111, 0, 12, "_from"));
      sol_address_t arg__to =
          Init_sol_address_t(GET_ND_RANGE(112, 0, 12, "_to"));
      sol_uint256_t arg__value =
          Init_sol_uint256_t(GET_ND_UINT(113, 256, "_value"));
      StandardToken_Method_For_GVOptionToken_transferFrom(
          contract_6, sender, value, blocknum, timestamp, paid, sender,
          arg__from, arg__to, arg__value);
      smartace_log("[Call successful]");
      break;
    }
    case 44: {
      smartace_log("[Calling approve(_spender, _value) on contract_6]");
      sol_address_t sender;
      ((sender).v) = (GET_ND_RANGE(114, 7, 12, "sender"));
      ((last_sender).v) = ((sender).v);
      sol_uint256_t value;
      ((value).v) = (0);
      sol_address_t arg__spender =
          Init_sol_address_t(GET_ND_RANGE(115, 0, 12, "_spender"));
      sol_uint256_t arg__value =
          Init_sol_uint256_t(GET_ND_UINT(116, 256, "_value"));
      StandardToken_Method_For_GVOptionToken_approve(
          contract_6, sender, value, blocknum, timestamp, paid, sender,
          arg__spender, arg__value);
      smartace_log("[Call successful]");
      break;
    }
    case 45: {
      smartace_log("[Calling allowance(_owner, _spender) on contract_6]");
      sol_address_t sender;
      ((sender).v) = (GET_ND_RANGE(117, 7, 12, "sender"));
      ((last_sender).v) = ((sender).v);
      sol_uint256_t value;
      ((value).v) = (0);
      sol_address_t arg__owner =
          Init_sol_address_t(GET_ND_RANGE(118, 0, 12, "_owner"));
      sol_address_t arg__spender =
          Init_sol_address_t(GET_ND_RANGE(119, 0, 12, "_spender"));
      StandardToken_Method_For_GVOptionToken_allowance(
          contract_6, sender, value, blocknum, timestamp, paid, sender,
          arg__owner, arg__spender);
      smartace_log("[Call successful]");
      break;
    }
    case 46: {
      smartace_log("[Calling transfer(_to, _value) on contract_6]");
      sol_address_t sender;
      ((sender).v) = (GET_ND_RANGE(120, 7, 12, "sender"));
      ((last_sender).v) = ((sender).v);
      sol_uint256_t value;
      ((value).v) = (0);
      sol_address_t arg__to =
          Init_sol_address_t(GET_ND_RANGE(121, 0, 12, "_to"));
      sol_uint256_t arg__value =
          Init_sol_uint256_t(GET_ND_UINT(122, 256, "_value"));
      BasicToken_Method_For_GVOptionToken_transfer(contract_6, sender, value,
                                                   blocknum, timestamp, paid,
                                                   sender, arg__to, arg__value);
      smartace_log("[Call successful]");
      break;
    }
    case 47: {
      smartace_log("[Calling balanceOf(_owner) on contract_6]");
      sol_address_t sender;
      ((sender).v) = (GET_ND_RANGE(123, 7, 12, "sender"));
      ((last_sender).v) = ((sender).v);
      sol_uint256_t value;
      ((value).v) = (0);
      sol_address_t arg__owner =
          Init_sol_address_t(GET_ND_RANGE(124, 0, 12, "_owner"));
      BasicToken_Method_For_GVOptionToken_balanceOf(contract_6, sender, value,
                                                    blocknum, timestamp, paid,
                                                    sender, arg__owner);
      smartace_log("[Call successful]");
      break;
    }
    default: {
      sol_require(0, "Model failure, next_call out of bounds.");
    }
    }
    if (contract_1.model_address.v == tmp_sender.v) {
      if (called_a || called_b) {
        sol_assert(contract_1.user_icoState.v == 4, "Property");
      }
    }
  }
}